.TH LKET 5 @DATE@ "IBM"
.SH NAME
LKET \- Linux Kernel Event Trace tool based on SystemTap

.\" macros
.de SAMPLE
.br
.RS
.nf
.nh
..
.de ESAMPLE
.hy
.fi
.RE
..

.SH DESCRIPTION

The Linux Kernel Event Trace (LKET) tool is an extension to the tapsets
library available on SystemTap. Its goal is to utilize the dynamic probing
capabilities provided through SystemTap to create a set of standard hooks
that probe pre-defined places in the kernel. It can be used to collect
important information that can be used as a starting point to analyze 
a performance problem in the system.

The LKET tapsets are designed to only trace the events selected by the
user. Once the data has been collected, it is then post-processed 
according to the need of the user. Trace data can be processed in 
various different ways to generate simple to complex reports.  

.SH EVENT HOOKS

The following sections enumerate the variety of event hooks implemented
in LKET and their trace data format. The trace data generated by different
event hooks contain common data
as well as some data specific to that event hook. 

the INT8, INT16, INT32, INT64 and STRING appeared in trace data format
represents 8-bit, 16-bit, 32-bit, 64-bit binary data and NULL-terminated
string respectively.

The data common(i.e.
.I common_data
in the following subsecions) to all event hooks is:
.RS

.B usec(INT64),(tid<<32 | groupID<<24 | hookID<<16 | cpu_id<<8)(INT64)
.RE

Each event hook group is a collection of those hooks that have
similarities of what they could trace. And the ID of each event hook (HookID)
is defined in the context of its corresponding group.

.SS EVENT REGISTER (GROUPID=1)
Event register is not actually an event. It is used to log the 
metadata of the trace data, including the extra trace data appended by user.
See
.B EVENT REGISTER
and
.B CUSTOMIZED TRACE DATA
for more details.

.P
.TP
.B register_sys_event(HOOKID=1)
This is a function used to register event hooks available in LKET. 
It should be called from register_event.stp:register_sys_events().

.TP
.B register_user_event(HOOKID=2)
This is a function used to log the metadata of the extra
trace data appended by user for a specific event.
It should be called in the probe
.I register_event

.SS SYSTEM CALLS (GROUPID=2)
You could use 
.I addevent.syscall
to trace the entry and return of all system calls.
It contains two sub event hooks:
.P
.TP
.B addevent.syscall.entry (HOOKID=1)
Trace entry of all system calls. 

Data format is:

.I common_data, syscall_name(STRING)
.TP
.B addevent.syscall.return (HOOKID=2)
Trace return of all system calls. 

Data format is:

.I common_data, syscall_name(STRING)

.SS PROCESS CREATION (GROUPID=3)
This group contains three sub event hooks.
You could use
.I addevent.process
to trace fork and execve of processes(note that process_snapshot()
won't be included).
.P
.TP
.B process_snapshot()(HOOKID=1)
This event hook isn't a probe definition but a function. It is called
by LKET silently to take a snapshot of all running processes.

Data format is:

.I common_data, tid(INT32), pid(INT32), ppid(INT32), process_name(STRING)

.P
.TP
.B addevent.process.fork (HOOKID=2)
Trace fork of processes

Data format is:

.I common_data, new_tid(INT32), new_pid(INT32), ppid(INT32)
.TP
.B addevent.process.execve (HOOKID=3)
Trace execve of new processes

Data format is:

.I common_data, pid(INT32), new_process_name(STRING)

.SS IO SCHEDULER ACTIVITIES (GROUPID=4)
You could use
.I addevent.ioscheduler
to trace the IO scheduler activities. It contains three sub event hooks:
.P
.TP
.B addevent.ioscheduler.elv_add_request (HOOKID=1)
Trace when a request is added to the request queue

Data format is:

.I common_data, elevator_name(STRING), disk_major(INT8), disk_minor(INT8), 
.I request(INT64), request_flags(INT64)
.TP
.B addevent.ioscheduler.elv_next_request (HOOKID=2)
Trace when a request is retrieved from request queue

Data format is:

.I common_data, elevator_name(STRING), disk_major(INT8), disk_minor(INT8), 
.I request(INT64), request_flags(INT64)

.TP
.B addevent.ioscheduler.elv_completed_request (HOOKID=3)
Trace when a request is completed

Data format is:

.I common_data, elevator_name(STRING), disk_major(INT8), disk_minor(INT8), 
.I request(INT64), request_flags(INT64)

.SS TASK SCHEDULE ACTIVITIES (GROUPID=5)
You could use
.I addevent.tskdispatch
to trace the task scheduler activities. It contains two sub event hooks:
.P
.TP
.B addevent.tskdispatch.ctxswitch (HOOKID=1)
Trace the process context switch

Data format is:

.I common_data, prev_pid(INT32), next_pid(INT32), prev_state(INT8)
.TP
.B addevent.tskdispatch.cpuidle (HOOKID=2)
Trace when cpu goes idle

Data format is:

.I common_data, current_pid(INT32)

.SS SCSI ACTIVITIES (GROUPID=6)
You could use
.I addevent.scsi
to trace the scsi layer activities. It contains four sub event hooks:
.P
.TP
.B addevent.scsi.ioentry (HOOKID=1)
mid-layer prepares a IO request

Data format is:

.I common_data, disk_major(INT8), disk_minor(INT8), device_state(INT8), request(INT64)
.TP
.B addevent.scsi.iodispatching (HOOKID=2)
Dispatch a command to the low-level driver

Data format is:

.I common_data, device_state(INT8), scsi_info(INT32), data_direction(INT8), 
.I reqbuf_addr(INT64), reqbuf_len(INT32), cmd_identifier(INT64), request(INT64)

Where 
.I scsi_info
is the combination of:

.SAMPLE
((cmd\->device\->host\->host_no & 0xFF) << 24) |
((cmd\->device\->channel & 0xFF) << 16) |
((cmd\->device\->lun & 0xFF) << 8) |
(cmd\->device\->id & 0xFF)
.ESAMPLE

.TP
.B addevent.scsi.iodone (HOOKID=3)
I/O is done by low-level driver

Data format is:

.I common_data, scsi_info(INT32), data_direction(INT8), cmd_identifier(INT64), 
.I request(INT64)
.TP
.B addevent.scsi.iocompleted (HOOKID=4)
mid-layer processed the completed IO

Data format is:

.I common_data, scsi_info(INT32), data_direction(INT8), cmd_identifier(INT64),
.I bytes_done(INT32), request(INT64)

.SS PAGE FAULT (GROUPID=7)
You could use 
.I addevent.pagefault
to trace page fault events. It contains only one sub event hooks:
.P
.TP
.B addevent.pagefault (HOOKID=1)

Data format is:

.I common_data, memory_address(INT64), write_access(INT8)

.SS NETWORK DEVICE ACTIVITIES (GROUPID=8)
You could use
.I addevent.netdev
to trace the network device  activities. It contains two sub event hooks:
.P
.TP
.B addevent.netdev.receive (HOOKID=1)
network device receives a packet

Data format is:

.I common_data, netdev_name(STRING), data_length(INT32), protocol(INT16), 
.I buffer_length(INT32)

.TP
.BR addevent.netdev.transmit (HOOKID=2)
A packet will be sent out by network device

Data format is:

.I common_data, netdev_name(STRING), data_length(INT32), protocol(INT16), 
.I buffer_length(INT32)


.SS IO SYSCALLS (GROUPID=9)
You could use
.I addevent.iosyscall
to trace the detail activities of io related system calls. 
It contains 16 entry hooks and 16 corresponding
return hooks.

All the return hooks will only log the common_data and
the return value. So in the following subsections, only the entry 
hooks will be listed:

.P
.TP
.B addevent.iosyscall.open.entry (HOOKID=1)
the entry of sys_open

Data format is:

.I common_data, filename(STRING), flags(INT32), mode(INT32)

.TP
.B addevent.iosyscall.close.entry (HOOKID=3)
the entry of sys_close

Data format is:

.I common_data, fd(INT64)

.TP
.B addevent.iosyscall.read.entry (HOOKID=5)
the entry of sys_read

Data format is:

.I common_data, fd(INT64), buf_addr(INT64), count(INT64)

.TP
.B addevent.iosyscall.write.entry (HOOKID=7)
the entry of sys_write

Data format is:

.I common_data, fd(INT64), buf_addr(INT64), count(INT64)

.TP
.B addevent.iosyscall.readv.entry (HOOKID=9)
the entry of sys_readv

Data format is:

.I common_data, fd(INT64), vector_addr(INT64), count(INT64)

.TP
.B addevent.iosyscall.writev.entry (HOOKID=11)
the entry of sys_writev

Data format is:

.I common_data, fd(INT64), vector_addr(INT64), count(INT64)

.TP
.B addevent.iosyscall.pread64.entry (HOOKID=13)
the entry of sys_pread64

Data format is:

.I common_data, fd(INT64), buff_addr(INT64), count(INT64), offset(INT64)

.TP
.B addevent.iosyscall.pwrite64.entry (HOOKID=15)
the entry of sys_pwrite64

Data format is:

.I common_data, fd(INT64), buff_addr(INT64), count(INT64), offset(INT64)

.TP
.B addevent.iosyscall.readahead.entry (HOOKID=17)
the entry of sys_readahead

Data format is:

.I common_data, fd(INT64), offset(INT64), count(INT64)

.TP
.B addevent.iosyscall.senfile.entry (HOOKID=19)
the entry of sys_sendfile and sys_sendfile64

Data format is:

.I common_data, out_fd(INT64), in_fd(INT64), offset_uaddr(INT64), count(INT64)

.TP
.B addevent.iosyscall.lseek.entry (HOOKID=21)
the entry of sys_lseek

Data format is:

.I common_data, fd(INT64), offset(INT64), whence(INT8)

.TP
.B addevent.iosyscall.llseek.entry (HOOKID=23)
the entry of sys_llseek

Data format is:

.I common_data, fd(INT64), offset_high(INT64), offset_low(INT64), 
.I result_addr(INT64), whence(INT8)

.TP
.B addevent.iosyscall.sync.entry (HOOKID=25)
the entry of sys_sync

Data format is:

.I common_data

.TP
.B addevent.iosyscall.fsync.entry (HOOKID=27)
the entry of sys_fsync

Data format is:

.I common_data, fd(INT64)

.TP
.B addevent.iosyscall.fdatasync.entry (HOOKID=29)
the entry of sys_fdatasync

Data format is:

.I common_data, fd(INT64)

.TP
.B addevent.iosyscall.flock.entry (HOOKID=31)
the entry of sys_flock

Data format is:

.I common_data, fd(INT64), operation(INT32)

.SS Asynchronous IO (GROUPID=10)
You could use
.I addevent.aio
to trace the detail activities of AIO related calls(most of them
are AIO system calls). 
It contains 6 entry hooks and 6 corresponding return hooks.

All the return hooks will only log the common_data and
the return value. So in the following subsections, only the entry 
hooks will be listed:

.P
.TP
.B addevent.aio.io_setup.entry (HOOKID=1)
Fired by calling io_setup from user space. The corresponding
system call is sys_io_setup, which will create an aio_context
capable of receiving at least maxevents.

Data format is:

.I common_data, nr_events(INT32), ctxp_uaddr(INT64)

.TP
.B addevent.aio.io_submit.entry (HOOKID=3)
Fired by calling io_submit from user space. The corresponding
system call is sys_io_submit which will queue the nr iocbs 
pointed to by iocbpp_uaddr for processing.

Data format is:

.I common_data, ctx_id(INT64), nr(INT32), iocbpp_uaddr(INT64)

.TP
.B addevent.aio.io_submit_one.entry (HOOKID=5)
Called by sys_io_submit. It will iterate iocbpp and process them
one by one

Data format is:

.I common_data, ctx(INT64), user_iocb_uaddr(INT64), aio_lio_opcode(INT16), 
.I aio_reqprio(INT16), aio_fildes(INT32), aio_buf(INT64), aio_nbytes(INT64),
.I aio_offset(INT64)

.TP
.B addevent.aio.io_getevents.entry (HOOKID=7)
Fired by calling io_getevents from user space. The corresponding
system call is sys_io_getevents, which will attempt to
read at least min_nr events and up to nr events from  the completion
queue for the aio_context specified by ctx_id.

Data format is:

.I common_data, ctx_id(INT64), min_nr(INT32), nr(INT32), events_uaddr(INT64),
.I tv_sec(INT32), tv_nsec(INT32)

.TP
.B addevent.aio.io_destroy.entry (HOOKID=9)
Fired by calling io_destroy from user space. The corresponding
system call is sys_io_destroy, which will destroy
the aio_context specified.

Data format is:

.I common_data, ctx(INT64)

.TP
.B addevent.aio.io_cancel.entry (HOOKID=11)
Fired by calling io_cancel from user space. The corresponding
system call is sys_io_cancel, which will attempt to cancel an 
iocb previously passed to io_submit.

Data format is:

.I common_data, ctx_id(INT64), iocb_uaddr(INT64), result_uaddr(INT64)

.SS SUNRPC(GROUPID=12)
You could use
.I addevent.sunrpc
to trace the details of SUNRPC activities. It is now divided into three
groups: high-level client operation event hooks (addevent.sunrpc.clnt),
high-level server operation event hooks (addevent.sunrpc.svc) and RPC
scheduler operation event hooks (addevent.sunrpc.sched). 
It contains 19 entry hooks and 19 corresponding return hooks.

All the return hooks will only log the common_data and the return value.
So in the following subsections, only the entry hooks will be listed:

.P
.TP
.B addevent.sunrpc.clnt.create_client.entry (HOOKID=1)
Fires when an RPC client is to be created

Data format is:

.I common_data, servername(STRING), prog(INT64), vers(INT8),
.I prot(INT16), port(INT16), authflavor(INT8)

.TP
.B addevent.sunrpc.clnt.clone_client.entry (HOOKID=3)
Fires when the RPC client structure is to be cloned

Data format is:

.I common_data, servername(STRING), prog(INT64), vers(INT8),
.I prot(INT16), port(INT16), authflavor(INT8)

.TP
.B addevent.sunrpc.clnt.shutdown_client.entry (HOOKID=5)
Fires when an RPC client is to be shut down

Data format is:

.I common_data, servername(STRING), prog(INT64), clones(INT16),
.I tasks(INT16), rpccnt(INT32)

.TP
.B addevent.sunrpc.clnt.bind_new_program.entry (HOOKID=7)
Fires when a new RPC program is to be bound an existing client

Data format is:

.I common_data, servername(STRING), old_prog(INT64), old_vers(INT8),
.I prog(INT64), vers(INT8)

.TP
.B addevent.sunrpc.clnt.call_sync.entry (HOOKID=9)
Fires when an RPC procedure is to be called synchronously

Data format is:

.I common_data, servername(STRING), prog(INT64), vers(INT8),
.I proc(INT64), flags(INT64) 

.TP
.B addevent.sunrpc.clnt.call_async.entry (HOOKID=11)
Fires when an RPC procedure is to be called asynchronously

Data format is:

.I common_data, servername(STRING), prog(INT64), vers(INT8),
.I proc(INT64), flags(INT64) 

.TP
.B addevent.sunrpc.clnt.restart_call.entry (HOOKID=13)
Fires when want to restart a task

Data format is:

.I common_data, tk_pid(INT64), tk_flags(INT64)

.TP
.B addevent.sunrpc.svc.register.entry (HOOKID=33)
Fires when an RPC service is to be registered with the local
portmapper

Data format is:

.I common_data, sv_name(STRING), prog(INT64), prot(INT16),
.I port(INT32)

.TP
.B addevent.sunrpc.svc.create.entry (HOOKID=35)
Fires when an RPC service is to be created

Data format is:

.I common_data, prog(INT64), pg_nvers(INT8), bufsize(INT32)

.TP
.B addevent.sunrpc.svc.destroy.entry (HOOKID=37)
Fires when an RPC service is to be destroyed

Data format is:

.I common_data, sv_name(STRING), sv_prog(INT64), sv_nrthreads(INT32)

.TP
.B addevent.sunrpc.svc.process.entry (HOOKID=39)
Fires when an RPC request is to be processed

Data format is:

.I common_data, sv_name(STRING), sv_prog(INT64), peer_ip(INT64),
.I rq_xid(INT64), rq_prog(INT64), rq_vers(INT8), rq_proc(INT8)

.TP
.B addevent.sunrpc.svc.authorise.entry (HOOKID=41)
Fires when an RPC request is to be authorised

Data format is:

.I common_data, sv_name(STRING), peer_ip(INT64), rq_xid(INT64),
.I rq_prog(INT64), rq_vers(INT8), rq_proc(INT64)

.TP
.B addevent.sunrpc.svc.recv.entry (HOOKID=43)
Fires when receiving the next request on any socket

Data format is:

.I common_data, sv_name(STRING), timeout(INT64)

.TP
.B addevent.sunrpc.svc.send.entry (HOOKID=45)
Fires when want to return reply to the client

Data format is:

.I sv_name(STRING), peer_ip(INT64), rq_xid(INT64), rq_prog(INT64), 
.I rq_vers(INT8), rq_proc(INT64)

.TP
.B addevent.sunrpc.svc.drop.entry (HOOKID=47)
Fires when a request is to be dropped

Data format is:

.I common_data, sv_name(STRING), peer_ip(INT64), rq_xid(INT64),
.I rq_prog(INT64), rq_vers(INT8), rq_proc(INT64)

.TP
.B addevent.sunrpc.sched.new_task.entry (HOOKID=65)
Fires when creating a new task for the specified client

Data format is:

.I common_data, xid(INT64), prog(INT64), vers(INT8), prot(INT64),
.I flags(INT64)

.TP
.B addevent.sunrpc.sched.release_task.entry (HOOKID=67)
Fires when releasing a task

Data format is:

.I common_data, xid(INT64), prog(INT64), vers(INT8), prot(INT64),
.I flags(INT64)

.TP
.B addevent.sunrpc.sched.execute.entry (HOOKID=69)
Fires when an RPC request is to be executed

Data format is:

.I common_data, xid(INT64), prog(INT64), vers(INT8), prot(INT64),
.I tk_pid(INT64), tk_flags(INT64)

.TP
.B addevent.sunrpc.sched.delay.entry (HOOKID=71)
Fires when want to delay an RPC request

Data format is:

.I common_data, xid(INT64), prog(INT64), tk_pid(INT64),
.I tk_flags(INT64), delay(INT64)

.SS NFS (GROUPID=16)
You could use
.I addevent.nfs
to trace the detail activities of nfs on client side. 
It divided into three groups: nfs file operation event hooks(addevent.nfs.fop),
nfs address space operation event hooks(addevent.nfs.aop), nfs proc event hooks(addevent.nfs.proc).
It contains 36 entry hooks and 33 corresponding return hooks

All the return hooks will only log the common_data and
the return value. So in the following subsections, only the entry 
hooks will be listed:

.P
.TP
.B addevent.nfs.fop.llseek.entry (HOOKID=1)
the entry of nfs_file_llseek 

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I offset(INT32), origin(INR8)

.TP
.B addevent.nfs.fop.read.entry (HOOKID=3)
the entry of do_sync_read 

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I buf_addr(INT64), count(INT64) , offset(INT64)

.TP
.B addevent.nfs.fop.write.entry (HOOKID=5)
the entry of do_sync_write

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I buf_addr(INT64), count(INT64) , offset(INT64)

.TP
.B addevent.nfs.fop.aio_read.entry (HOOKID=7)
the entry of nfs_file_read 

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I buf_addr(INT64), count(INT64) , offset(INT64)

.TP
.B addevent.nfs.fop.aio_write.entry (HOOKID=9)
the entry of nfs_file_read 

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I buf_addr(INT64), count(INT64) , offset(INT64)

.TP
.B addevent.nfs.fop.mmap.entry (HOOKID=11)
the entry of nfs_file_mmap

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I vm_start(INT64), vm_end(INT64) , vm_flags(INT32)

.TP
.B addevent.nfs.fop.open.entry (HOOKID=13)
the entry of nfs_file_open

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I flag(INT32), filename(STRING)

.TP
.B addevent.nfs.fop.flush.entry (HOOKID=15)
the entry of nfs_file_flush

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I ndirty(INT32)

.TP
.B addevent.nfs.fop.release.entry (HOOKID=17)
the entry of nfs_file_release

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I mode(INT16)

.TP
.B addevent.nfs.fop.fsync.entry (HOOKID=19)
the entry of nfs_fsync

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I ndirty(INT32)

.TP
.B addevent.nfs.fop.lock.entry (HOOKID= 21)
the entry of nfs_lock

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I fl_start(INT64), fl_end(INT64), fl_type(INT8), fl_flag(INT8), cmd(INT32)

.TP
.B addevent.nfs.fop.sendfile.entry (HOOKID= 23)
the entry of nfs_file_sendfile

Data format is:

.I common_data, major_device(INT8), minor_devide(INT8), fileid(INT32), 
.I count(INT64), ppos(INT64)

.TP
.B addevent.nfs.fop.checkflags.entry (HOOKID= 25)
the entry of nfs_check_flags

Data format is:

.I flag(INT32)

.TP
.B addevent.nfs.aop.readpage.entry (HOOKID= 27)
the entry of nfs_readpage

Data format is:

.I fileid(INT64), rsize(INT32), page_address(INT64), page_index(INT64)

.TP
.B addevent.nfs.aop.readpages.entry (HOOKID= 29)
the entry of nfs_readpages

Data format is:

.I fileid(INT64), rpages(INT32), nr_pages(INT32)

.TP
.B addevent.nfs.aop.writepage.entry (HOOKID= 31)
the entry of nfs_writepage

Data format is:

.I fileid(INT64), wsize(INT32), page_address(INT64), page_index(INT64)

.TP
.B addevent.nfs.aop.writepages.entry (HOOKID= 33)
the entry of nfs_writepages

Data format is:

.I fileid(INT64), wpages(INT32), nr_to_write(INT64)

.TP
.B addevent.nfs.aop.prepare_write.entry (HOOKID= 35)
the entry of nfs_prepare_write

Data format is:

.I fileid(INT64), page_address(INT64), page_index(INT64)

.TP
.B addevent.nfs.aop.commit_write.entry (HOOKID= 37)
the entry of nfs_commit_write

Data format is:

.I fileid(INT64), page_address(INT64), page_index(INT64),offset(INT32),count(INT32)

.TP
.B addevent.nfs.aop.set_page_dirty.entry (HOOKID= 39)
the entry of __set_page_dirty_nobuffers

Data format is:

.I page_address(INT64), page_flag(INT8)

.TP
.B addevent.nfs.aop.release_page.entry (HOOKID= 41)
the entry of nfs_release_page 

Data format is:

.I page_address(INT64), page_index(INT64)

.TP
.B addevent.nfs.proc.lookup.entry (HOOKID= 43)
the entry of nfs_proc_lookup , nfs3_proc_lookup and nfs4_proc_lookup

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I filename(STRING)

.TP
.B addevent.nfs.proc.read.entry (HOOKID= 45)
the entry of nfs_proc_read, nfs3_proc_read and nfs4_proc_read

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I count(INT32),offset(INT64)

.TP
.B addevent.nfs.proc.write.entry (HOOKID= 47)
the entry of nfs_proc_write, nfs3_proc_write and nfs4_proc_write

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I count(INT32),offset(INT64)

.TP
.B addevent.nfs.proc.commit.entry (HOOKID= 49)
Fires when client writes the buffered data to disk,the buffered data is asynchronously written by client before .
The commit function works in sync way,not exist in NFSV2

the entry of  nfs3_proc_commit and nfs4_proc_commit

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I count(INT32),offset(INT64)

.TP
.B addevent.nfs.proc.read_setup.entry (HOOKID= 51)
The read_setup function is used to setup a read rpc task,not do a real read operation

the entry of  nfs_proc_read_setup, nfs3_proc_read_setup and nfs4_proc_read_setup

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I count(INT32),offset(INT64)

.TP
.B addevent.nfs.proc.write_setup.entry (HOOKID= 52)
The write_setup function is used to setup a write rpc task,not do a real write operation

the entry of  nfs_proc_write_setup, nfs3_proc_write_setup and nfs4_proc_write_setup

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I how(INT8), count(INT32),offset(INT64)

.TP
.B addevent.nfs.proc.commit_setup.entry (HOOKID= 53)
The commit_setup function is used to setup a commit rpc task,not do a real commit operation.It is not exist in NFSV2

the entry of nfs3_proc_commit_setup and nfs4_proc_commit_setup

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I how(INT8), count(INT32),offset(INT64)

.TP
.B addevent.nfs.proc.read_done.entry (HOOKID= 54)
Fires when a read reply is received or some read error occur (timeout or socket shutdown)

the entry of nfs_read_done, nfs3_read_done and nfs4_read_done

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I status(INT32), count(INT32)

.TP
.B addevent.nfs.proc.write_done.entry (HOOKID= 56)
Fires when a write reply is received or some write error occur (timeout or socket shutdown)

the entry of nfs_write_done, nfs3_write_done and nfs4_write_done

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I status(INT32), count(INT32)

.TP
.B addevent.nfs.proc.commit_done.entry (HOOKID= 58)
Fires when a commit reply is received or some commit operation error occur (timeout or socket shutdown)

the entry of nfs_commit_done, nfs3_commit_done and nfs4_commit_done

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I status(INT32), count(INT32)

.TP
.B addevent.nfs.proc.open.entry (HOOKID= 60)
the entry of nfs_open 

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I filename(STRING), flag(INT32), mode(INT32)

.TP
.B addevent.nfs.proc.release.entry (HOOKID= 62)
the entry of nfs_release

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I filename(STRING), flag(INT32), mode(INT32)

.TP
.B addevent.nfs.proc.create.entry (HOOKID= 64)
the entry of nfs_proc_create, nfs3_proc_create, nfs4_proc_create

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I filename(STRING), mode(INT32)

.TP
.B addevent.nfs.proc.rename.entry (HOOKID= 66)
the entry of nfs_proc_rename, nfs3_proc_rename, nfs4_proc_rename

Data format is:

.I version(INT8), major_old(INT8), minor_old(INT8), old_fileid(INT64), old_name(STRING),
.I major_new(INT8), minor_new(INT8), new_fileid(INT64), new_name(STRING) 

.TP
.B addevent.nfs.proc.remove.entry (HOOKID= 68)
the entry of nfs_proc_remove, nfs3_proc_remove, nfs4_proc_remove

Data format is:

.I major_dev(INT8), minor_dev(INT8), fileid(INT64), version(INT8),
.I filename(STRING)

.SS NFSD (GROUPID=17)
You could use
.I addevent.nfsd
to trace the detail activities of nfs on server side. 
It divided into two groups: nfsd operation event hooks(addevent.nfsd.op),
nfsd proc event hooks(addevent.nfsd.proc).
It contains 19 entry hooks and 19 corresponding return hooks

All the return hooks will only log the common_data and
the return value. So in the following subsections, only the entry 
hooks will be listed:

.P
.TP
.B addevent.nfsd.dispatch.entry (HOOKID= 1)
Fires when server receives a NFS operation from client

the entry of nfsd_dispatch 

Data format is:

.I proto(INT8), version(INT8), xid(INT32), proc(INT32),client_ip(INT32)

.TP
.B addevent.nfsd.open.entry (HOOKID= 3)
the entry of nfsd_open

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I type(INT32), access(INT32)

.TP
.B addevent.nfsd.read.entry (HOOKID= 5)
the entry of nfsd_read

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I count(INT64), offset(INT64), iov_len(INT64), vlen(INT64)

.TP
.B addevent.nfsd.write.entry (HOOKID= 7)
the entry of nfsd_write

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I count(INT64), offset(INT64), iov_len(INT64), vlen(INT64)

.TP
.B addevent.nfsd.lookup.entry (HOOKID= 9)
the entry of nfsd_lookup

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I filename(STRING)

.TP
.B addevent.nfsd.commit.entry (HOOKID= 11)
the entry of nfsd_commit

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I count(INT64), offset(INT64)

.TP
.B addevent.nfsd.create.entry (HOOKID= 13)
Fires when client creates a file(regular,dir,device,fifo) on server side,
sometimes nfsd will call nfsd_create_v3 instead of this function

the entry of nfsd_create

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I filename(STRING), type(INT32), iap_valid(INT16), iap_mode(INT32)

.TP
.B addevent.nfsd.createv3.entry (HOOKID= 15)
Fires when client creates a regular file or set file attributes on server side,
only called by nfsd3_proc_create and nfsd4_open(op_claim_type is NFS4_OPEN_CLAIM_NULL)

the entry of nfsd_create_v3

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I filename(STRING), createmode(INT8), iap_valid(INT16), iap_mode(INT32)

.TP
.B addevent.nfsd.unlink.entry (HOOKID= 17)
the entry of nfsd_unlink

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), 
.I filename(STRING), type(INT32)

.TP
.B addevent.nfsd.rename.entry (HOOKID= 19)
the entry of nfsd_rename

Data format is:

.I old_fhsize(INT8), old_fh0(INT64), old_fh1(INT64), old_fh2(INT64), old_name(STRING)
.I new_fhsize(INT8), new_fh0(INT64), new_fh1(INT64), new_fh2(INT64), new_name(STRING)

.TP
.B addevent.nfsd.close.entry (HOOKID= 21)
the entry of nfsd_close

Data format is:

.I filename(STRING)
 
.TP
.B addevent.nfsd.proc.lookup.entry (HOOKID= 23)
the entry of nfsd_proc_lookup, nfsd3_proc_lookup

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), version(INT8)
.I filename(STRING)
 
.TP
.B addevent.nfsd.proc.read.entry (HOOKID= 25)
the entry of nfsd_proc_read, nfsd3_proc_read

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), version(INT8)
.I count(INT64), offset(INT64), iov_len(INT64), vlen(INT64)
 
.TP
.B addevent.nfsd.proc.write.entry (HOOKID= 27)
the entry of nfsd_proc_write, nfsd3_proc_write

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), version(INT8)
.I count(INT64), offset(INT64), iov_len(INT64), vlen(INT64)
 
.TP
.B addevent.nfsd.proc.commit.entry (HOOKID= 29)
the entry of nfsd_proc_commit, nfsd3_proc_commit

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), version(INT8)
.I count(INT64), offset(INT64)
 
.TP
.B addevent.nfsd.proc.commit.entry (HOOKID= 31)
the entry of nfsd4_proc_compound

Data format is:

.I number(INT32)
 
.TP
.B addevent.nfsd.proc.remove.entry (HOOKID= 33)
the entry of nfsd4_proc_compound

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), version(INT8)
.I filename(STRING)
 
.TP
.B addevent.nfsd.proc.rename.entry (HOOKID= 35)
the entry of nfsd_proc_rename, nfsd3_proc_rename

Data format is:

.I old_fhsize(INT8), old_fh0(INT64), old_fh1(INT64), old_fh2(INT64), old_name(STRING)
.I new_fhsize(INT8), new_fh0(INT64), new_fh1(INT64), new_fh2(INT64), new_name(STRING)

.TP
.B addevent.nfsd.proc.create.entry (HOOKID= 37)
the entry of nfsd_proc_create, nfsd3_proc_create

Data format is:

.I fh_size(INT8), fhandle0(INT64), fhandle1(INT64), fhandle2(INT64), version(INT8)
.I filename(STRING)

.SH TRACE DATA FORMAT

By default, LKET will log the trace data in binary format.

To get a better performance for binary tracing, the "\-b" option should
be turned on for stap and thus \-M option has to be added to stop staprun
merging per-cpu files.

You could use the command 
.I lket\-b2a
to convert the binary trace data 
generated by LKET into readable data in ascii format.

.I lket\-b2a
uses the pre-cpu binary trace data files as inputs, and generates
an output file named 
.I lket.out
You should use "stap \-b \-M" with LKET to get those pre-cpu files
(stpd_cpu*) before using it.

If you want LKET to log trace data in ASCII format directly, you should:
.SAMPLE
stap \-D ASCII_TRACE ...
.ESAMPLE

.SH EVENT REGISTER

LKET provides a way to log the metadata of the trace data by events registering.

Two function is provided:
.P
.IP 
.SB register_sys_event(grpid:long, hookid:long, fmt:string, names:string)
.IP
.SB register_user_event(grpid:long, hookid:long, fmt:string, names:string)
.P

The 
.I grpid
and 
.I hookid
is the groupid and hookid of the event you want to register. 

.I fmt
contains a set of fomat tokens seperated by ":".
The valid format tokens are:
.B UINT8,
.B UINT16,
.B UINT32,
.B UINT64
and
.B STRING
which represents 8-bit, 16-bit, 32-bit, 64-bit binary data and NULL-terminated
respectively.

.I names
contains a set of names seperated by ":".
The names contains in
.I names
should match the format tokens contains in
.I fmt

.B register_sys_event 
is used to register the newly added event hooks. For example, supposing you
want to add a new event hook to trace the entry of sys_open, and you want
this event hook to log the fd, flag and mode paremeters for you. You should
add:

.SAMPLE
register_sys_event(GROUP_IOSYSCALL, HOOKID_IOSYSCALL_OPEN_ENTRY,
	"STRING:INT32:INT32", "filename:flags:mode")
.ESAMPLE

into the function
.B register_sys_events
in LKET/register_event.stp


.B register_user_event
is used for user to add extra trace data for a event hook. See
the section
.B CUSTOMIZED TRACE DATA
for more detail


.SH CUSTOMIZED TRACE DATA

LKET defines a set of event hooks and will log the predefined
trace data for you, but what if you want to trace extra 
data for that event?

LKET provides a way to do this without modifying the codes in
the tapset of that event hook. You can simply use printf to trace
extra data. For example, supposing you want to trace sk_buff\->mac_len
and sk_buff\->priority besides the sk_buff\->len, sk_buff\->protocol and
sk_buff\->truesize for the 
.B netdev 
event hooks:

.SAMPLE
probe register_event
{
    register_user_event(GROUP_NETDEV, HOOKID_NETDEV_TRANSMIT,
        "INT32:INT32", "mac_len:priority")
}
probe addevent.netdev.transmit
{
    printf("%4b%4b", $skb\->mac_len, $skb\->priority)
}
.ESAMPLE

.SH EXAMPLES

Here are some examples of using LKET:

.TP
To turn on all event hooks:
stap \-e "probe addevent.* {}" \-bM
.TP
To probe syscall:
stap \-e "probe addevent.syscall {}" \-bM
.TP
To only probe syscall.entry:
stap \-e "probe addevent.syscall.entry {}" \-bM
.TP
To probe netdev transmition and log extra data of mac_len and priority:
stap \-e "probe addevent.netdev.transmit { printf(\\"%4b%4b\\", $skb\->mac_len, $skb\->priority) }" \-bM

.SH SEE ALSO
.IR stap (1)
