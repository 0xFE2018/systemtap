# maxactive.exp
#
# Check to see if using the 'maxactive(N)' limit on return probes
# works, by seeing if skipped probes increases when using it.

if {[info procs installtest_p] != "" && ![installtest_p]} {
    untested "MAXACTIVE"
    return
}

# stap_run variant that sets 'skipped_probes' to the number of skipped
# probes in a run.
#
# stap_run_skipped TEST_NAME
# TEST_NAME is path to the current test
# Additional arguments are passed to stap as-is.
proc stap_run_skipped { TEST_NAME args } {
    global skipped_probes

    # initialize skipped_probes to 0
    set skipped_probes 0

    set cmd [concat {stap -v} $args]
    eval spawn $cmd
    expect {
	-re {^Pass\ ([1234]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms.\r\n}
	{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"; exp_continue}
	-re {^Pass\ ([34]): using cached .+\r\n}
	{set pass$expect_out(1,string) "\t0\t0\t0"; exp_continue}
	-re {^Pass 5: starting run.\r\n} {exp_continue}
	-timeout 30 -re "^systemtap starting probe\r\n" {
	    pass "$TEST_NAME startup"

	    # check the output to see if it is sane
	    set output "^systemtap ending probe\r\n"

	    expect {
		-re $output {
		    pass "$TEST_NAME shutdown and output"
		    expect {
			-re {^Pass\ ([5]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms.\r\n}
			{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"
			    verbose -log "metric:\t$TEST_NAME $pass1$pass2$pass3$pass4$pass5"}
			-re {^WARNING: Number of errors: 0, skipped probes: ([0-9]+)\r\n}
			{set skipped_probes $expect_out(1,string)}
		    }
		}
		timeout { fail "$TEST_NAME shutdown (timeout)" }
		eof { fail "$TEST_NAME shutdown (eof)" }
	    }
	}
	-re "semantic error:" { fail "$TEST_NAME compilation" }
	timeout { fail "$TEST_NAME startup (timeout)"; send "\003" }
	eof { fail "$TEST_NAME startup (eof)" }
    }
  catch close
  wait
}

# Script1.  For 5 seconds, probe the return of "sys_select" and
# "sys_read".  See if we skip any probes.
set script1 {
    probe kernel.function("sys_select").return,
        kernel.function("sys_read").return { }

    probe timer.ms(5000) { exit(); }
    probe begin { log("systemtap starting probe"); }
    probe end { log("systemtap ending probe"); }
}

# Run script1 and save the number of skipped probes (which will most
# likely be 0).
stap_run_skipped "MAXACTIVE01" -e $script1
set skipped1 $skipped_probes

# Script2.  For 5 seconds, probe the return of "sys_select" and
# "sys_read", with a limit of 1 probe active at a time.  See if we
# skip any probes.
set script2 {
    probe kernel.function("sys_select").return.maxactive(1),
        kernel.function("sys_read").return.maxactive(1) { }

    probe timer.ms(5000) { exit(); }
    probe begin { log("systemtap starting probe"); }
    probe end { log("systemtap ending probe"); }
}

# Run script2 and save the number of skipped probes.
stap_run_skipped "MAXACTIVE02" -e $script2
set skipped2 $skipped_probes

# If the number of skipped probes for script 1 is less than the number
# of skipped probes for script 2, we can assume that "maxactive(N)" is
# working.
#
# Note that this isn't 100% accurate based on the system load at the
# time of the scripts.
set TEST_NAME "MAXACTIVE03"
if {$skipped1 < $skipped2} {
    pass "$TEST_NAME ($skipped1 skipped probes < $skipped2 skipped probes)"
} else {
    fail "$TEST_NAME ($skipped1 skipped probes > $skipped2 skipped probes)"
}
