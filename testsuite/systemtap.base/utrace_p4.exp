# Utrace compile (pass 4) tests.  We can't run these as
# testsuite/buildok tests, since if the current kernel has no utrace
# support, those will fail - but not because of a problem with
# systemtap's utrace probes (but because of the lack of utrace).  So,
# this test script checks for the existence of utrace in the kernel.
# If utrace exists in the kernel, it tries some compile tests.  If
# utrace doesn't exist in the kernel, marks the tests as 'untested'.

# stap_compile TEST_NAME flags script args
# - TEST_NAME is the name of the current test
# - compile indicates whether the script is supposed to compile
# - script is the script to compile
# Additional arguments are passed to stap as-is.
proc stap_compile { TEST_NAME compile script args } {
    set cmd [concat {stap -v -p4 -e} $script $args]
    
    verbose -log "running $cmd" 
    eval spawn $cmd
    set compile_errors 0
    expect {
	-re {^Pass\ [1234]:[^\r]*\ in\ .*\ ms.\r\n} {exp_continue}
	-re {^Pass\ [34]: using cached [^\r\n]+\r\n} {exp_continue}
        # pass-4 output
	-re {^/[^\r\n]+.ko\r\n} {exp_continue}
	-re "parse error" { incr compile_errors 1; exp_continue}
	-re "compilation failed" {incr compile_errors 1; exp_continue}
	-re "semantic error:" {incr compile_errors 1; exp_continue}
    }
    catch close
    wait

    # If we've got compile errors and the script was supposed to
    # compile, fail.
    if {$compile_errors > 0} {
	if {$compile == 1} {
	    fail "$TEST_NAME compilation failed"
	} else {
	    pass "$TEST_NAME compilation failed correctly"
	}
    } else {
	if {$compile == 1} {
	    pass "$TEST_NAME compilation succeeded"
	} else {
	    fail "$TEST_NAME compilation succeeded unexpectedly"
	}
    }
}

# Initialize variables
set utrace_support_found 0

set clone_script {"probe process(\"/bin/ls\").clone { print(\"ls clone\") }"}
set death_script {"probe process(\"/bin/ls\").death { print(\"ls death\") }"}
set syscall_script {"probe process(\"/bin/ls\").syscall { printf(\"|%d\", \$syscall) }"}
set syscall_return_script {"probe process(\"/bin/ls\").syscall.return { printf(\"|%d\", \$syscall) }"}

# Try to find utrace_attach symbol in /proc/kallsyms
set path "/proc/kallsyms"
if {! [catch {exec grep -q utrace_attach $path} dummy]} {
    set utrace_support_found 1
}

#
# Do some utrace compile tests.
#

set TEST_NAME "UTRACE_P4_01"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a clone script
    stap_compile $TEST_NAME 1 $clone_script
}

set TEST_NAME "UTRACE_P4_02"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a death script
    stap_compile $TEST_NAME 1 $death_script
}

set TEST_NAME "UTRACE_P4_03"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a syscall script
    stap_compile $TEST_NAME 1 $syscall_script
}

set TEST_NAME "UTRACE_P4_04"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a syscall return script
    stap_compile $TEST_NAME 1 $syscall_return_script
}
