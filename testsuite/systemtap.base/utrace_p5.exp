# Utrace run (pass 5) tests.

# Initialize variables
set utrace_support_found 0
set exepath "[pwd]/cat_[pid]"

set end_script {
    global end_probes_fired = 0
    probe begin { printf("systemtap starting probe\n") }
    probe process("%s").end { end_probes_fired++ }
    probe end { printf("systemtap ending probe\n")
	printf("end probes = %%d\n", end_probes_fired) }
}
set end_script_output "end probes = 1\r\n"

set begin_script {
    global begin_probes_fired = 0
    probe begin { printf("systemtap starting probe\n") }
    probe process("%s").begin { begin_probes_fired++ }
    probe end { printf("systemtap ending probe\n")
	printf("begin probes = %%d\n", begin_probes_fired) }
}
set begin_script_output "begin probes = 1\r\n"

set syscall_script {
    global syscall_probes_fired = 0
    probe begin { printf("systemtap starting probe\n") }
    probe process("%s").syscall { syscall_probes_fired++ }
    probe end { printf("systemtap ending probe\n")
	if (syscall_probes_fired > 0) {
	    printf("syscalls = %%d\n", syscall_probes_fired)
	}
    }
}
set syscall_script_output "syscalls = \\d+\r\n"

set syscall_return_script {
    global syscall_return_probes_fired = 0
    probe begin { printf("systemtap starting probe\n") }
    probe process("%s").syscall.return { syscall_return_probes_fired++ }
    probe end { printf("systemtap ending probe\n")
	if (syscall_return_probes_fired > 0) {
	    printf("syscall_returns = %%d\n", syscall_return_probes_fired)
	}
    }
}
set syscall_return_script_output "syscall_returns = \\d+\r\n"

# Try to find utrace_attach symbol in /proc/kallsyms
set path "/proc/kallsyms"
if {! [catch {exec grep -q utrace_attach $path} dummy]} {
    set utrace_support_found 1
}

# Set up our own copy of /bin/cat, to make testing for a particular
# executable easy.  We can't use 'ln' here, since we might be creating
# a cross-device link.  We can't use 'ln -s' here, since the kernel
# resolves the symbolic link and reports that /bin/cat is being
# exec'ed (instead of our local copy).
if {[catch {exec cp /bin/cat $exepath} res]} {
    fail "unable to copy /bin/cat: $res"
    return
}

# "load" generation function for stap_run.  It spawns our own copy of
# /bin/cat, waits 5 seconds, then kills it.
proc run_cat_5_sec {} {
    global exepath

    spawn $exepath
    set exe_id $spawn_id
    after 5000;
    exec kill -INT -[exp_pid -i $exe_id]
    return 0;
}

set TEST_NAME "UTRACE_P5_01"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} elseif {![installtest_p]} {
    untested "$TEST_NAME"
} else {
    set script [format $end_script $exepath]
    stap_run $TEST_NAME run_cat_5_sec $end_script_output -e $script
}

set TEST_NAME "UTRACE_P5_02"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} elseif {![installtest_p]} {
    untested "$TEST_NAME"
} else {
    set script [format $begin_script $exepath]
    stap_run $TEST_NAME run_cat_5_sec $begin_script_output -e $script
}

set TEST_NAME "UTRACE_P5_03"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} elseif {![installtest_p]} {
    untested "$TEST_NAME"
} else {
    set script [format $syscall_script $exepath]
    stap_run $TEST_NAME run_cat_5_sec $syscall_script_output -e $script
}

set TEST_NAME "UTRACE_P5_04"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} elseif {![installtest_p]} {
    untested "$TEST_NAME"
} else {
    set script [format $syscall_return_script $exepath]
    stap_run $TEST_NAME run_cat_5_sec $syscall_return_script_output -e $script
}

# We need thread.begin and thread.end tests!

# Cleanup
exec rm -f $exepath
