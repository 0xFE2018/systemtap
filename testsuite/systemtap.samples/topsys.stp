#! stap -g
#
# This script continuously lists the top 20 systemcalls in the interval 
# of 2000 jiffies.
#

global syscalls_count, syscalls

function syscall_name:string () %{
	char *str, buff[80];
	char *tok;
	str = buff;
	strlcpy(str, CONTEXT->probe_point, sizeof(buff));
	tok = strsep(&str, "\"");
	tok = strsep(&str, "@");
	sprintf(str, "%-25s", tok);
	strlcpy(THIS->__retvalue, str, MAXSTRINGLEN);
%}

function reset_maxaction () %{
	if (CONTEXT && CONTEXT->actioncount)
		CONTEXT->actioncount=0;
%}
	
function accumulate () {
	syscall=syscall_name()
	syscalls_count[syscall]++
	# I use this array to refer to syscalls_count array in 
	# the reset_syscalls_count. Initalize with a non-zero. 
	syscalls[syscall]=1	 
}


function print_top () {
	lcnt=0
	reset_maxaction ()
	foreach ([syscall] in syscalls_count-) {
		sys_cnt = syscalls_count[syscall]
		log (syscall . "\t\t\t\t" . sprint(sys_cnt))
		if (lcnt++ == 20)
			break;
	}
	syscalls_count[lsyscall]=0
}

function reset_syscalls_count () {
	# For some reason, I have to do this to get pass the elaboration
	# phase on RHEL4 (seg fault). Under FC4, it works fine with out
	# the 'dummy_init'
	syscalls["dummy_init"]=0
	foreach ([sys] in syscalls) 
		syscalls_count[sys]=0
}

function print_systop () {
	log ("SYSCALL                  \t\t\t\tCOUNT")
	print_top()
	reset_syscalls_count ()
}

probe kernel.function("sys_*").call {
	accumulate ()
}

probe timer.jiffies(2000) {
	print_systop ()
	log("--------------------------------------------------------------")
}

