load_lib site.exp

proc installtest_p {} {
    global TOOL_OPTIONS
    if {[info exists TOOL_OPTIONS] && ($TOOL_OPTIONS == "install")} {
        return 1
    } else { return 0 }
}

proc print_systemtap_version {} {
    set version [exec /bin/uname -r]
    set location "/boot/vmlinux-$version"
    if {! [file exists $location]} {
	# try the debuginfo location
	set location "/usr/lib/debug/lib/modules/$version/vmlinux"
	if {! [file exists $location]} { set location "" }
    }

    print "kernel location: $location"
    print "kernel version: $version"

    set location [exec /usr/bin/which stap]
    regexp {version [^)]*} [exec stap -V 2>@ stdout] version

    print "systemtap location: $location"
    print "systemtap version: $version"
}


proc setup_systemtap_environment {} {
    global srcdir prefix env

    # need an absolute SRCDIR for the top-level src/ tree
    # XXX: or, we could change nearby uses of ${SRCDIR}/testsuite to ${SRCDIR}
    if {[string index $srcdir 0] != "/"} then {
        set env(SRCDIR) [exec pwd]/$srcdir/..
    } else {
        set env(SRCDIR) $srcdir/..
    }

    # Use a local systemtap directory and cache
    set env(SYSTEMTAP_DIR) [exec pwd]/.systemtap

    # PATH, SYSTEMTAP_TAPSET, SYSTEMTAP_RUNTIME, LD_LIBRARY_PATH are already set.
    foreach var {PATH STAP SRCDIR SYSTEMTAP_TAPSET SYSTEMTAP_RUNTIME SYSTEMTAP_DIR LD_LIBRARY_PATH} {
        if [info exists env($var)] {
            verbose -log "env $var = $env($var)"
        }
    }
}


setup_systemtap_environment
print_systemtap_version

proc systemtap_init {args} {}
proc systemtap_version {} {}
proc systemtap_exit {} {}


proc stap_run_batch {args} {
    verbose -log "starting $args"

    # Many of our test cases use "#! stap ...".  Since these lack
    # /full/paths, they are not really executable.  (We can't have
    # /full/paths because the choice of systemtap interpreter is set
    # at "make check" time.)

    # So we cheat.  If the file begins with "#! stap", we will spawn
    # stap manually here (relying on $PATH).  Otherwise, we presume
    # the file properly executable.

    set file [open [lindex $args 0] r]
    set firstbits [gets $file]
    close $file
    if [regexp -line {\#! stap (.*)} $firstbits -> stap_args] {
        verbose -log "spawn1 stap $stap_args [lindex $args 0]"
        spawn stap $stap_args [lindex $args 0]
    } else {
        verbose -log "spawn2 $args"
        spawn $args
    }

    expect { 
        -re {[^\r]*\r} { verbose -log $expect_out(0,string); exp_continue } 
        eof { }
        timeout { exp_continue } 
    }
    set results [wait]
    verbose -log "wait results: $results"
    # Crashed?
    if {[llength $results] >= 5} {return 1}
    # Not?
    return [lindex $results 3]
}
