# stap_run.exp
#
# Will Cohen
# 8/12/2005


# stap_run TEST_NAME LOAD_GEN_FUNCTION OUTPUT_CHECK_STRING
# TEST_NAME is path to the current test
# LOAD_GEN_FUNCTION (optional) to produce something to measure
#     returns 0 if successful
#     returns 1 if there was a problem
# OUTPUT_CHECK_STRING (optional) examines the output of experiment
#     returns 0 if successful
#     returns 1 if there was a problem
# Additional arguments are passed to stap as-is.
proc stap_run { TEST_NAME {LOAD_GEN_FUNCTION ""} {OUTPUT_CHECK_STRING ""} args } {
    if {[info procs installtest_p] != "" && ![installtest_p]} { untested $TEST_NAME; return }

    set cmd [concat {stap -v} $args]
    if [file readable $TEST_NAME] {
        lappend cmd $TEST_NAME
    }
    eval spawn $cmd
    expect {
	-re {^Pass\ ([1234]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms.\r\n}
	{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"; exp_continue}
	-re {^Pass 5: starting run.\r\n} {exp_continue}
	-timeout 30 -re "^systemtap starting probe\r\n" {
	    pass "$TEST_NAME startup"
	    if {$LOAD_GEN_FUNCTION != ""} then {
		#run the interesting test here
		if {[eval $LOAD_GEN_FUNCTION] == 0} then {
		    pass "$TEST_NAME load generation"
		} else {
		    fail "$TEST_NAME load generation"
		}
	    }

	    send "\003"

	    #check the output to see if it is sane
	    set output "^systemtap ending probe\r\n$OUTPUT_CHECK_STRING"

	    expect {
		-re  $output {
		    pass "$TEST_NAME shutdown and output"
		    expect {
			-re {^Pass\ ([5]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms.\r\n}
			{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"
			    verbose -log "metric:\t$TEST_NAME $pass1$pass2$pass3$pass4$pass5"}
		    }
		}
		timeout { fail "$TEST_NAME shutdown (timeout)" }
		eof { fail "$TEST_NAME shutdown (eof)" }
	    }
	}
	-re "semantic error:" { fail "$TEST_NAME compilation" }
	timeout { fail "$TEST_NAME startup (timeout)"; send "\003" }
	eof { fail "$TEST_NAME startup (eof)" }
    }
  catch close
  wait
}

proc no_load {} {
# nothing in here
# load to use when nothing is needed
    return 0
}

# tests better all be true
set all_pass_string "(systemtap test success\r\n)+"
