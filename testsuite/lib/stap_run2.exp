# stap_run2.exp
#
# Simple script for testing multiple lines of exact output.
    
# stap_run2 TEST_NAME
# TEST_NAME is path to the current test
# Additional arguments are passed to stap as-is.
#
# global result_string must be set to the expected output

proc stap_run2 { TEST_NAME args } {
    # zap the srcdir prefix
    set test_file_name $TEST_NAME
    set TEST_NAME [regsub {.*/testsuite/} $TEST_NAME ""]
    
    if {[info procs installtest_p] != "" && ![installtest_p]} { untested $TEST_NAME; return }
    
    # fix up expected string
    regsub -all \n $::result_string \r\n output
    
    # spawn test
    set cmd [concat {stap -v} $args]
    if [file readable $test_file_name] {
	lappend cmd $test_file_name
    }
    eval spawn $cmd
    
    expect {
	-timeout 180
	-re {^Pass\ ([1234]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms.\r\n}
	{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"; exp_continue}
	-re {^Pass\ ([34]): using cached .+\r\n}
	{set pass$expect_out(1,string) "\t0\t0\t0"; exp_continue}
	-re {^Pass 5: starting run.\r\n} {exp_continue}
	-ex $output {
	    pass "$TEST_NAME"
	    expect {
		-re {^Pass\ ([5]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms.\r\n}
		{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"
		    verbose -log "metric:\t$TEST_NAME $pass1$pass2$pass3$pass4$pass5"}
	    }
	}
	timeout { 
	    fail "$TEST_NAME timed out" }
	eof { 
	    fail "$TEST_NAME unexpected EOF" }
	-re "semantic error:" { fail "$TEST_NAME compilation" }
	-re "ERROR:" { 
	    send "\003"
	    fail "$TEST_NAME runtime error" 
	}
    }
    catch close
    wait
}
