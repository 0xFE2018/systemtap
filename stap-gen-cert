#!/bin/bash

# Generate a certificate for the systemtap server and add it to the
# database of trusted servers for the client.
#
# Copyright (C) 2008-2011 Red Hat Inc.
#
# This file is part of systemtap, and is free software.  You can
# redistribute it and/or modify it under the terms of the GNU General
# Public License (GPL); either version 2, or (at your option) any
# later version.

# Initialize the environment
. ${PKGLIBEXECDIR}stap-env

serverdb=
domains="$HOSTNAME"
use_db_password=0

# Arguments
while test $# != 0
do
  case "$1" in
    -P)
      use_db_password=1
      shift 1
      ;;
    --)
      ;;
    *)
      if test -z "$serverdb"; then
        # Server cert database
	serverdb="$1"
      else
        # Domains for the certificate.
        test -n "$domains" && domains="$domains,"
        domains="${domains}$1"
      fi
      ;;
  esac
  shift
done

# Obtain the certificate database directory name.
if  test "X$serverdb" = "X"; then
    serverdb="$stap_user_ssl_db/server"
fi
rm -fr "$serverdb"

# Create the server's certificate database directory.
if ! mkdir -p -m 755 "$serverdb"; then
    echo "Unable to create the server certificate database directory: $serverdb" >&2
    exit 1
fi

# If not using a database password, then create an empty certificate database password
# file. This is a temporary file used only because certutil demands it.
if test $use_db_password = 0; then
  if ! (touch "$serverdb/pw" && chmod 600 "$serverdb/pw"); then
    echo "Unable to create temporary certificate database password file: $serverdb/pw" >&2
    exit 1
  fi
  # Generate the server certificate database. Filter the message about the passowrd file
  # being empty.
  certutil -N -d "$serverdb" -f "$serverdb/pw" 2>&1 >/dev/null | \
    sed '/password file contains no data/ d'
else
  # Generate the server certificate database. certutil will ask for the password.
  certutil -N -d "$serverdb" >/dev/null
fi
rc=$?
rm -fr "$serverdb/pw"

if test $rc != 0; then
    echo "Unable to initialize the server certificate database directory: $serverdb" >&2
    exit 1
fi

# We need some random noise for generating keys
dd bs=123 count=1 < /dev/urandom > "$serverdb/noise" 2> /dev/null

# Generate a request for the server's certificate.
certutil -R -d "$serverdb" -s "CN=Systemtap Compile Server, OU=Systemtap" \
         -o "$serverdb/stap.req" -z "$serverdb/noise" 2> /dev/null
rm -fr "$serverdb/noise"

# Create the certificate file first so that it always has the proper access permissions.
if ! (touch "$serverdb/$stap_certfile" && chmod 644 "$serverdb/$stap_certfile"); then
    echo "Unable to create the server certificate file: $serverdb/$stap_certfile" >&2
    exit 1
fi

# Now generate the actual certificate. Make it valid for 1 year.
certutil -C -i "$serverdb/stap.req" -o "$serverdb/$stap_certfile" -x -d "$serverdb" \
         -v 12 -5 -8 "$domains" >/dev/null <<-EOF
1
3
7
8
y
EOF
rm -fr "$serverdb/stap.req"

# Add the certificate to the server's certificate/key database as a trusted peer, ssl server and object signer
certutil -A -n stap-server -t "PCu,,PCu" -i "$serverdb/$stap_certfile" -d "$serverdb"

# Print some information about the certificate.
echo "Certificate $serverdb/$stap_certfile created and added to database $serverdb"
certutil -L -d "$serverdb" -n stap-server | \
  awk '/Validity|Not After|Not Before/ { print $0 }' | \
  sed 's/^ */  /'

exit 0
