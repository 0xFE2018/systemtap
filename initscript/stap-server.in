#!/bin/bash
#
# stap-server	init.d script for the systemtap compile server
#
# chkconfig: - 00 99
# description: The systemtap compile server provides a centralized and secure environment for compiling systemtap scripts.
# config: /etc/stap-server/config
# config: /etc/stap-server/conf.d
### BEGIN INIT INFO
# Provides: Systemtap compile server management
# Required-Start: $local_fs
# Required-Stop: $local_fs
# Short-Description: Manage systemtap compile servers
# Description: The systemtap compile server provides a centralized and secure environment for compiling systemtap scripts.
### END INIT INFO

# Source function library.
. /etc/rc.d/init.d/functions

prog=stap-server

# Commands
STAP_START_SERVER=@bindir@/stap-start-server
STAP_STOP_SERVER=@bindir@/stap-stop-server
UNAME=/bin/uname

# Path setup
CONFIG_PATH=/etc/stap-server/conf.d
STAT_PATH=/var/run/stap-server
TEMP_PATH=/tmp
LOG_FILE=/var/log/stap-server.log

# Default option settings

CONFIG=/etc/stap-server/config

echo_usage () {
  echo $"Usage: $prog {start|stop|restart|status|cleanup} [option]"
  echo $"Options:"
  echo $"	-c configfile	: specify config file"
}

#-----------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------
log () { # message
  echo `LC_ALL=en date +"%b %e %T"`": $1" >> "$LOG_FILE"
}
clog () { # message [-n]
  echo $2 "$1"
  log "$1"
}
slog () { # message
  logger "$1" # if syslogd is running, this message will be sent to syslog.
  log "$1"
}
logex () { # command
  eval log \"Exec: $@\"
  "$@" >> "$LOG_FILE" 2>&1
  return $?
}
do_warning () { # message
  slog "Warning: $1"
  warning "$1"
}
do_failure () { # message
  slog "Error: $1"
  failure "$1"
}
do_success () { # message
  log "Pass: $1"
  success "$1"
}
# Normalize options
check_bool () { # value
  case $1 in
  n|N|no|No|NO|0)
  return 0;;
  y|Y|yes|Yes|YES|1)
  return 1;;
  *)
  return 2;;
  esac
}
ask_yesno () { # message
  local yn ret=2
  [ "$OPT_ASSUMEYES" ] && return 1
  while [ $ret -eq 2 ]; do
    echo -n "$1 [y/N]: "
    read yn
    [ -z "$yn" ] && return 0
    check_bool $yn
    ret=$?
  done
  return $ret
}

#------------------------------------------------------------------
# Parameter parsing and setup options
#------------------------------------------------------------------
parse_args () { # arguments
  local error=0
  while [ -n "$1" ]; do
    case "$1" in
      -c)
        CONFIG=$2
        shift 1
        ;;
      --)
        ;;
      *)
	error=1
        ;;
    esac
    shift 1
  done
  test error = 1 && echo_usage
}

CMD=$1
shift 1
OPTS=`getopt -s bash -u -o 'c:Ry' $@`
if [ $? -ne 0 ]; then
  slog "Error: Argument parse error: $@"
  failure $"parse error"
  echo_usage
  exit 3
fi
parse_args $OPTS

# Include configs
if [ -f "$CONFIG" ]; then
  . "$CONFIG"
fi

for f in "$CONFIG_PATH"/*.conf; do
  if [ -f "$f" ]; then
    . "$f"
  fi
done

prepare_stat_dir () {
  if [ ! -d "$STAT_PATH" ]; then
    logex mkdir -p "$STAT_PATH"
    [ $? -ne 0 ] && return 1
  fi
  return 0
}

start () {
  clog $"Starting $prog: " -n

  prepare_stat_dir
  if [ $? -ne 0 ]; then
    do_failure $"Failed to make stat directory ($STAT_PATH)"
    return 1
  fi

  # Start the server here
  do_failure $"$prog start not implemented"

  do_success $"$prog start"
  return 0
}

stop () {
  clog $"Stopping $prog: " -n

  # Stop the server here
  do_failure $"$prog stop not implemented"

  do_success $"$prog stop"
  return 0
}

status () {
  local ret=0

  # Print the status here
  echo $"$prog status not implemented"

  return $ret
}

# Cleanup caches
cleanup () {
  clog $"Stopping systemtap compile servers: " -n

  # Clean up the server(s) here
  do_failure $"$prog cleanup not implemented"

  do_success "done"
  return 0
}

# Restart scripts
function restart () {
  stop
  echo
  start
  return $?
}

RETVAL=0

case $CMD in
  start)
  start
  RETVAL=$?
  ;;
  stop)
  stop
  RETVAL=$?
  ;;
  restart)
  restart
  RETVAL=$?
  ;;
  status)
  status
  exit $?
  ;;
  cleanup)
  cleanup
  RETVAL=$?
  ;;
  *)
  echo_usage
  RETVAL=3
  ;;
esac

echo
exit $RETVAL
