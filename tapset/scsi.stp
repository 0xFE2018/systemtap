// scsi tapset
// Copyright (C) 2005, 2006 IBM Corp.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
#include <linux/types.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_host.h>
#include <linux/timer.h>
#include <linux/blkdev.h>
%}

/* mid-layer prepare a IO request */
probe scsi.ioentry
	= module("scsi_mod").function("scsi_prep_fn@drivers/scsi/scsi_lib.c")?,
	  kernel.function("scsi_prep_fn@drivers/scsi/scsi_lib.c")?
{
	if($req->rq_disk == 0)  {
		disk_major = -1
		disk_minor = -1
	} else {
		disk_major = $req->rq_disk->major
		disk_minor = $req->rq_disk->first_minor
	}
	device_state = get_devstate_from_req($q)
	req_addr = $req
}

/* Dispatch a command to the low-level driver. */
probe scsi.iodispatching
	= module("scsi_mod").function("scsi_dispatch_cmd@drivers/scsi/scsi.c")?,
	  kernel.function("scsi_dispatch_cmd@drivers/scsi/scsi.c")?
{

	host_no = $cmd->device->host->host_no
	channel = $cmd->device->channel
	lun = $cmd->device->lun
	dev_id = $cmd->device->id
	device_state = $cmd->device->sdev_state
	data_direction = $cmd->sc_data_direction
	request_buffer = $cmd->request_buffer
	request_bufflen = $cmd->request_bufflen
	req_addr = $cmd->request
}

/* I/O is done by low-level driver*/
probe scsi.iodone
	= module("scsi_mod").function("scsi_done@drivers/scsi/scsi.c")?,
	  kernel.function("scsi_done@drivers/scsi/scsi.c")?

{
	host_no = $cmd->device->host->host_no
	channel = $cmd->device->channel
	lun = $cmd->device->lun
	dev_id = $cmd->device->id
	device_state = $cmd->device->sdev_state
	data_direction = $cmd->sc_data_direction
	req_addr = $cmd->request
	scsi_timer_pending = scsi_timer_pending($cmd);
}

/* mid-layer processes the completed IO */
probe scsi.iocompleted
	= module("scsi_mod").function("scsi_io_completion@drivers/scsi/scsi_lib.c")?,
	  kernel.function("scsi_io_completion@drivers/scsi/scsi_lib.c")?
{
	host_no = $cmd->device->host->host_no
	channel = $cmd->device->channel
	lun = $cmd->device->lun
	dev_id = $cmd->device->id
	device_state = $cmd->device->sdev_state
	data_direction = $cmd->sc_data_direction
	req_addr = $cmd->request
	goodbytes = $good_bytes
}

function scsi_timer_pending:long(var:long)
%{
        struct scsi_cmnd *cmd = (struct scsi_cmnd *)((long)THIS->var);
        THIS->__retvalue = timer_pending(&cmd->eh_timeout); /* FIXME: deref hazard! */
%}

function get_devstate_from_req:long(var:long)
%{
	struct request_queue *q = (struct request_queue *)((long)THIS->var);
	struct scsi_device *sdev = (struct scsi_device *)kread(&(q->queuedata));
	THIS->__retvalue = kread(&(sdev->sdev_state));
	CATCH_DEREF_FAULT();
%}
