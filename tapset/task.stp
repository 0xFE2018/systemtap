// task information tapset
// Copyright (C) 2006 Intel Corporation.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
#include <linux/version.h>
#include <linux/file.h>
%}

// Return the task_struct representing the current process
function task_current:long () %{ /* pure */
    THIS->__retvalue = (long)current;
%}


// Return the parent task_struct of the given task
function task_parent:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = (long)kread(&(t->parent));
    CATCH_DEREF_FAULT();
%}


// Return the state of the given task, one of:
//   TASK_RUNNING           0
//   TASK_INTERRUPTIBLE     1
//   TASK_UNINTERRUPTIBLE   2
//   TASK_STOPPED           4
//   TASK_TRACED            8
//   EXIT_ZOMBIE           16
//   EXIT_DEAD             32
function task_state:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->state));
    CATCH_DEREF_FAULT();
%}


// Return the name of the given task
function task_execname:string (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    deref_string(THIS->__retvalue, t->comm, MAXSTRINGLEN);
    CATCH_DEREF_FAULT();
%}


// Return the process id of the given task
function task_pid:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->tgid));
    CATCH_DEREF_FAULT();
%}


// Return the thread id of the given task
function task_tid:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->pid));
    CATCH_DEREF_FAULT();
%}


// Return the group id of the given task
function task_gid:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->gid));
    CATCH_DEREF_FAULT();
%}


// Return the effective group id of the given task
function task_egid:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->egid));
    CATCH_DEREF_FAULT();
%}


// Return the user id of the given task
function task_uid:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->uid));
    CATCH_DEREF_FAULT();
%}


// Return the effective user id of the given task
function task_euid:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->euid));
    CATCH_DEREF_FAULT();
%}


// Return the priority value of the given task
function task_prio:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue =  kread(&(t->prio)) - MAX_RT_PRIO;
    CATCH_DEREF_FAULT();
%}


// Return the nice value of the given task
function task_nice:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    THIS->__retvalue = kread(&(t->static_prio)) - MAX_RT_PRIO - 20;
    CATCH_DEREF_FAULT();
%}


// Return the scheduled cpu for the given task
function task_cpu:long (task:long)
%( kernel_v >= "2.6.22" %? 
%{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    struct thread_info *ti = kread(&(t->stack));
    THIS->__retvalue = kread(&(ti->cpu));
    CATCH_DEREF_FAULT();
%}
%:
%{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    struct thread_info *ti = kread(&(t->thread_info));
    THIS->__retvalue = kread(&(ti->cpu));
    CATCH_DEREF_FAULT();
%}
%)


// Return the number of open file handlers for the given task
function task_open_file_handles:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    struct files_struct *f = kread(&(t->files));
    struct fdtable *fdt = kread(&(f->fdt));
    unsigned int count=0, fd, max;
    rcu_read_lock();
    max = kread(&(fdt->max_fds));
    for (fd = 0; fd < max; fd++) {
                if ( kread(&(fdt->fd[fd])) != NULL)
                        count ++;
        }
    rcu_read_unlock();
    THIS->__retvalue = count;
    CATCH_DEREF_FAULT();
%}


// Return the maximum number of file handlers for the given task
function task_max_file_handles:long (task:long) %{ /* pure */
    struct task_struct *t = (struct task_struct *)(long)THIS->task;
    struct files_struct *f = kread (&(t->files));
    struct fdtable *fdt = kread(&(f->fdt));
    rcu_read_lock();
    THIS->__retvalue = kread(&(fdt->max_fds));
    rcu_read_unlock();
    CATCH_DEREF_FAULT();
%}
