// TCP tapset
// Copyright (C) 2006 IBM Corp.
// Copyright (C) 2006 Intel Corporation.
// Copyright (C) 2007 Red Hat, Inc.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
#include <linux/version.h>
#include <net/sock.h>
#include <net/tcp.h>
#include <net/ip.h>
%}

// Get retransmission timeout in usecs. RTO is initialized from default
// retransmission time, but can be adjusted (increased) each time we 
// retransmit. It should always be less than the max value of TCP retransmission 
// timeout (TCP_RTO_MAX)
function tcp_get_info_rto:long(sock:long)
%{ /* pure */
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
	THIS->__retvalue = (int64_t) jiffies_to_usecs(kread(&(tp->rto)));
#else
	const struct inet_connection_sock *icsk = inet_csk(sk);
	THIS->__retvalue = (int64_t) jiffies_to_usecs(kread(&(icsk->icsk_rto)));
#endif
	CATCH_DEREF_FAULT();
%}

//Get congestion window segment size. Initial value of congestion window size 
//typically set to one segment (i.e., slow start algorithm, each segment can be 512 bytes).
//This congestion window size can be dynamically increased based on whether TCP
//is performing slow start or congestion avoidance. 
function tcp_get_info_snd_cwnd:long(sock:long)
%{ /* pure */
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
#else
	struct tcp_sock *tp = tcp_sk(sk);
#endif
	THIS->__retvalue = (int64_t) kread(&(tp->snd_cwnd));
	CATCH_DEREF_FAULT();
%}

//
//Definitions of the TCP protocol sk_state field listed below.
//
//     TCP_ESTABLISHED = 1,   Normal data transfer
//     TCP_SYN_SENT   = 2,   App. has started to open a connection
//     TCP_SYN_RECV   = 3,   A connection request has arrived; wait for ACK
//     TCP_FIN_WAIT1  = 4,   App. has said it is finished
//     TCP_FIN_WAIT2  = 5,   The other side has agreed to close
//     TCP_TIME_WAIT  = 6,   Wait for all packets to die off
//     TCP_CLOSE      = 7,   No connection is active or pending 
//     TCP_CLOSE_WAIT = 8,   The other side has initiated a release
//     TCP_LAST_ACK   = 9,   Last ACK, wait for all packets to die off
//     TCP_LISTEN     = 10,  Waiting for incoming call
//     TCP_CLOSING    = 11,  Both sides have tried to close simultaneously
//     TCP_MAX_STATES = 12   Max states number
// 
function tcp_ts_get_info_state:long(sock:long)
%{ /* pure */
	struct sock *sk = (struct sock *)(long) THIS->sock;
	THIS->__retvalue = (int64_t) kread(&(sk->sk_state));
	CATCH_DEREF_FAULT();
%}

function tcp_sockstate_str:string (state:long) {
	return (state in sockstate ? sockstate[state] : "UNDEF")
}

// Get slow start threshold size.  If cwnd size is less than or equal to
// threshold size, then TCP is in slow start; otherwise TCP is in congestion
// avoidance.
function tcp_ts_get_info_snd_ssthresh:long(sock:long)
%{ /* pure */
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
#else
	struct tcp_sock *tp = tcp_sk(sk);
#endif
	THIS->__retvalue = (int64_t) kread(&(tp->snd_ssthresh));
	CATCH_DEREF_FAULT();
%}

// Get receiver's advertised segment size.  TCP typically never sends more
// than what receiver can accept.
function tcp_ts_get_info_rcv_mss:long(sock:long)
%{ /* pure */
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
	THIS->__retvalue = (int64_t) kread(&(tp->ack.rcv_mss));
#else
	const struct inet_connection_sock *icsk = inet_csk(sk);
	THIS->__retvalue = (int64_t) kread(&(icsk->icsk_ack.rcv_mss));
#endif
	CATCH_DEREF_FAULT();
%}

function tcp_sockopt_str:string (optname:long) {
	return (optname in sockopt ? sockopt[optname] : "UNDEF")
}

// probe tcp.sendmsg
//
//  Fires whenever sending a tcp message  
//
// Context:
//  The process which sends a tcp message 
//
// Arguments:
//  name         - name of this probe
//  sock         - network socket 
//  size         - number of bytes to send  
//
probe tcp.sendmsg = kernel.function("tcp_sendmsg") {
	name = "tcp.sendmsg"
%( kernel_v < "2.6.23" %?
	sock    = $sk
%:
	sock = $sock
%)
	size    = $size
}

// probe tcp.sendmsg.return
//
//  Fires whenever sending message is done 
//
// Context:
//  The process which sends a tcp message
//
// Arguments:
//  name         - name of this probe
//  size         - number of bytes sent or
//                 error code if an error occurred. 
//
probe tcp.sendmsg.return = kernel.function("tcp_sendmsg").return {
	name = "tcp.sendmsg"
	size = $return 
}

// probe tcp.recvmsg
//
//  Fires whenever a message is received 
//
// Context:
//  The process which receives a tcp message
//
// Arguments:
//  name         - name of this probe
//  sock         - network socket
//  size         - number of bytes to be received  
//
probe tcp.recvmsg = kernel.function("tcp_recvmsg") {
	name = "tcp.recvmsg"
	sock    = $sk
	size    = $len
}

// probe tcp.recvmsg.return
//
//  Fires whenever message receiving is done 
//
// Context:
//  The process which receives a tcp message
//
// Arguments:
//  name         - name of this probe
//  size         - number of bytes received or
//                 error code if an error occurred.
//
probe tcp.recvmsg.return = kernel.function("tcp_recvmsg").return {
	name = "tcp.recvmsg"
	size = $return
}

// probe tcp.disconnect
//
//  Fires whenever tcp is disconnected 
//
// Context:
//  The process which disconnects tcp 
//
// Arguments:
//  name         - name of this probe
//  sock         - network socket 
//  flags        - TCP flags (e.g. FIN, etc)  
//
probe tcp.disconnect = kernel.function("tcp_disconnect") {
	name = "tcp.disconnect"
	sock  = $sk
	flags = $flags
}

// probe tcp.disconnect.return
//
// Fires when returning from tcp.disconnect 
//
// Context:
//  The process which disconnects tcp
// 
// Arguments:
//  name         - name of this probe
//  ret          - error code (0: no error) 
//
probe tcp.disconnect.return = kernel.function("tcp_disconnect").return {
	name = "tcp.disconnect"
	ret = $return 
}

// probe tcp.setsockopt
//
//  Fires whenever setsockopt(s, IPPROTO_TCP, TCP_*, ...) is called
//
// Context:
//  The process which calls setsockopt
//
// Arguments:
//  name         - name of this probe
//  sock         - network socket
//  level        - the level at which the socket options will be manipulated
//  optname      - TCP socket options (e.g. TCP_NODELAY, TCP_MAXSEG, etc)
//  optstr       - resolves optname to a human-readable format
//  optlen       - used to access values for setsockopt()
//
probe tcp.setsockopt = kernel.function("tcp_setsockopt") {
	name = "tcp.setsockopt"
	sock = $sk
	level = $level
	optname = $optname
	optstr = tcp_sockopt_str($optname)
	optlen = $optlen
}

// probe tcp.setsockopt.return
//
//  Fires whenever setsockopt(s, IPPROTO_TCP, TCP_*, ...) is done
//
// Context:
//  The process which calls setsockopt
//
// Arguments:
//  name         - name of this probe
//  ret          - error code (0: no error)
//
probe tcp.setsockopt.return = kernel.function("tcp_setsockopt").return {
	name = "tcp.setsockopt"
	ret = $return
}

global sockopt[15], sockstate[13]

probe begin(-1) {
        sockopt[1] = "TCP_NODELAY"
        sockopt[2] = "TCP_MAXSEG"
        sockopt[3] = "TCP_CORK"
        sockopt[4] = "TCP_KEEPIDLE"
        sockopt[5] = "TCP_KEEPINTVL"
        sockopt[6] = "TCP_KEEPCNT"
        sockopt[7] = "TCP_SYNCNT"
        sockopt[8] = "TCP_LINGER2"
        sockopt[9] = "TCP_DEFER_ACCEPT"
        sockopt[10] = "TCP_WINDOW_CLAMP"
        sockopt[11] = "TCP_INFO"
        sockopt[12] = "TCP_QUICKACK"
        sockopt[13] = "TCP_CONGESTION"
        sockopt[14] = "TCP_MD5SIG"

	sockstate[1] = "TCP_ESTABLISHED"
	sockstate[2] = "TCP_SYN_SENT"
	sockstate[3] = "TCP_SYN_RECV"
	sockstate[4] = "TCP_FIN_WAIT1"
	sockstate[5] = "TCP_FIN_WAIT2"
	sockstate[6] = "TCP_TIME_WAIT"
	sockstate[7] = "TCP_CLOSE"
	sockstate[8] = "TCP_CLOSE_WAIT"
	sockstate[9] = "TCP_LAST_ACK"
	sockstate[10] = "TCP_LISTEN"
	sockstate[11] = "TCP_CLOSING"
	sockstate[12] = "TCP_MAX_STATES"
}
