// TCP tapset
// Copyright (C) 2006 IBM Corp.
// Copyright (C) 2006 Intel Corporation.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
#include <linux/version.h>
#include <net/sock.h>
#include <net/tcp.h>
#include <net/ip.h>
%}

// Get retransmission timeout in usecs. RTO is initialized from default
// retransmission time, but can be adjusted (increased) each time we 
// retransmit. It should always be less than the max value of TCP retransmission 
// timeout (TCP_RTO_MAX)
function tcp_get_info_rto:long(sock:long)
%{
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
	THIS->__retvalue = (int64_t) jiffies_to_usecs(kread(&(tp->rto)));
#else
	const struct inet_connection_sock *icsk = inet_csk(sk);
	THIS->__retvalue = (int64_t) jiffies_to_usecs(kread(&(icsk->icsk_rto)));
#endif
	CATCH_DEREF_FAULT();
%}

//Get congestion window segment size. Initial value of congestion window size 
//typically set to one segment (i.e., slow start algorithm, each segment can be 512 bytes).
//This congestion window size can be dynamically increased based on whether TCP
//is performing slow start or congestion avoidance. 
function tcp_get_info_snd_cwnd:long(sock:long)
%{
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
#else
	struct tcp_sock *tp = tcp_sk(sk);
#endif
	THIS->__retvalue = (int64_t) kread(&(tp->snd_cwnd));
	CATCH_DEREF_FAULT();
%}

//
//Definitions of the TCP protocol sk_state field listed below.
//
//     TCP_ESTABLISED = 1,   Normal data transfer
//     TCP_SYN_SENT   = 2,   App. has started to open a connection
//     TCP_SYN_RECV   = 3,   A connection request has arrived; wait for ACK
//     TCP_FIN_WAIT1  = 4,   App. has said it is finished
//     TCP_FIN_WAIT2  = 5,   The other side has agreed to close
//     TCP_TIME_WAIT  = 6,   Wait for all packets to die off
//     TCP_CLOSE      = 7,   No connection is active or pending 
//     TCP_CLOSE_WAIT = 8,   The other side has initiated a release
//     TCP_LAST_ACK   = 9,   Last ACK, wait for all packets to die off
//     TCP_LISTEN     = 10,  Waiting for incoming call
//     TCP_CLOSING    = 11,  Both sides have tried to close simultaneously
//     TCP_MAX_STATES = 12   Max states number
// 
function tcp_ts_get_info_state:long(sock:long)
%{
	struct sock *sk = (struct sock *)(long) THIS->sock;
	THIS->__retvalue = (int64_t) kread(&(sk->sk_state));
	CATCH_DEREF_FAULT();
%}


// Get slow start threshold size.  If cwnd size is less than or equal to
// threshold size, then TCP is in slow start; otherwise TCP is in congestion
// avoidance.
function tcp_ts_get_info_snd_ssthresh:long(sock:long)
%{
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
#else
	struct tcp_sock *tp = tcp_sk(sk);
#endif
	THIS->__retvalue = (int64_t) kread(&(tp->snd_ssthresh));
	CATCH_DEREF_FAULT();
%}

// Get receiver's advertised segment size.  TCP typically never sends more
// than what receiver can accept.
function tcp_ts_get_info_rcv_mss:long(sock:long)
%{
	struct sock *sk = (struct sock *)(long) THIS->sock;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
	struct tcp_opt *tp = tcp_sk(sk);
	THIS->__retvalue = (int64_t) kread(&(tp->ack.rcv_mss));
#else
	const struct inet_connection_sock *icsk = inet_csk(sk);
	THIS->__retvalue = (int64_t) kread(&(icsk->icsk_ack.rcv_mss));
#endif
	CATCH_DEREF_FAULT();
%}

// probe tcp.sendmsg
//
//  Fires whenever sending a tcp message  
//
// Context:
//  The process which sends a tcp message 
//
// Arguments:
//  sock         - network socket 
//  size         - number of bytes to send  
//
probe tcp.sendmsg = kernel.function("tcp_sendmsg") {
	sock    = $sk
	size    = $size
}

// probe tcp.sendmsg.return
//
//  Fires whenever sending message is done 
//
// Context:
//  The process which sends a tcp message
//
// Arguments:
//  size         - number of bytes sent 
//
probe tcp.sendmsg.return = kernel.function("tcp_sendmsg").return {
	size = $return 
}

// probe tcp.recvmsg
//
//  Fires whenever a message is received 
//
// Context:
//  The process which receives a tcp message
//
// Arguments:
//  sock         - network socket
//  size         - number of bytes to be received  
//
probe tcp.recvmsg = kernel.function("tcp_recvmsg") {
	sock    = $sk
	size    = $len
}

// probe tcp.recvmsg.return
//
//  Fires whenever message receiving is done 
//
// Context:
//  The process which receives a tcp message
//
// Arguments:
//  size         - number of bytes received
//
probe tcp.recvmsg.return = kernel.function("tcp_recvmsg").return {
	size = $return
}

// probe tcp.disconnect
//
//  Fires whenever tcp is disconnected 
//
// Context:
//  The process which disconnects tcp 
//
// Arguments:
// sock       - network socket 
// flags      - TCP flags (e.g. FIN, etc)  
//
probe tcp.disconnect = kernel.function("tcp_disconnect") {
	sock  = $sk
	flags = $flags
}

// probe tcp.disconnect.return
//
// Fires when returning from tcp.disconnect 
//
// Context:
//  The process which disconnects tcp
// 
// Arguments:
//  ret         - error code (0: no error) 
//
probe tcp.disconnect.return = kernel.function("tcp_disconnect").return {
	ret = $return 
}
