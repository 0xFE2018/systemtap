# SunRPC trace hooks
# Copyright (C) 2006 IBM Corp.
# 
# This file is part of systemtap, and is free software.  You can
# redistribute it and/or modify it under the terms of the GNU General
# Public License (GPL); either version 2, or (at your option) any
# later version.
#
probe never 
{
	printf("%d\n", GROUP_SUNRPC) 
}

probe addevent.sunrpc
	= addevent.sunrpc.entry, addevent.sunrpc.return
{}

probe addevent.sunrpc.entry
	=
	addevent.sunrpc.clnt.entry,
	addevent.sunrpc.svc.entry,
	addevent.sunrpc.sched.entry
{}

probe addevent.sunrpc.return
	=
	addevent.sunrpc.clnt.return,
	addevent.sunrpc.svc.return,
	addevent.sunrpc.sched.return
{}

/******************************************************************
 *        trace hooks on high level RPC client functions          *  
 ******************************************************************/
probe addevent.sunrpc.clnt 
	= addevent.sunrpc.clnt.entry, addevent.sunrpc.clnt.return
{}

probe addevent.sunrpc.clnt.entry
	= 
	addevent.sunrpc.clnt.create_client.entry,
	addevent.sunrpc.clnt.clone_client.entry,
	addevent.sunrpc.clnt.bind_new_program.entry,
	addevent.sunrpc.clnt.shutdown_client.entry,
	addevent.sunrpc.clnt.call_sync.entry,
	addevent.sunrpc.clnt.call_async.entry,
	addevent.sunrpc.clnt.restart_call.entry
{}

probe addevent.sunrpc.clnt.return
	= 
	addevent.sunrpc.clnt.create_client.return,
	addevent.sunrpc.clnt.clone_client.return,
	addevent.sunrpc.clnt.bind_new_program.return,
	addevent.sunrpc.clnt.shutdown_client.return,
	addevent.sunrpc.clnt.call_sync.return,
	addevent.sunrpc.clnt.call_async.return,
	addevent.sunrpc.clnt.restart_call.return
{}

// Fires when an RPC client is to be created
probe addevent.sunrpc.clnt.create_client.entry
	+= _addevent.sunrpc.clnt.create_client.entry
{
	update_record()
}

probe _addevent.sunrpc.clnt.create_client.entry
	= sunrpc.clnt.create_client
{
	log_sunrpc_client_info(HOOKID_SUNRPC_CLNT_CREATE_CLIENT_ENTRY,
			servername, prog, vers, prot, port, authflavor)
}

probe addevent.sunrpc.clnt.create_client.return
	+= _addevent.sunrpc.clnt.create_client.return
{
	update_record()
}

probe _addevent.sunrpc.clnt.create_client.return
	= sunrpc.clnt.create_client.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_CLNT_CREATE_CLIENT_RETURN, 
			$return)
}

// Fires when the RPC client structure is to be cloned
probe addevent.sunrpc.clnt.clone_client.entry
	+= _addevent.sunrpc.clnt.clone_client.entry
{
	update_record()
}

probe _addevent.sunrpc.clnt.clone_client.entry
	= sunrpc.clnt.clone_client
{
	log_sunrpc_client_info(HOOKID_SUNRPC_CLNT_CLONE_CLIENT_ENTRY, 
			servername, prog, vers, prot, port, authflavor)
}

probe addevent.sunrpc.clnt.clone_client.return
	+= _addevent.sunrpc.clnt.clone_client.return
{
	update_record()
}

probe _addevent.sunrpc.clnt.clone_client.return
	= sunrpc.clnt.clone_client.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_CLNT_CLONE_CLIENT_RETURN, 
			$return)
}

// Fires when an RPC client is to be shut down.
probe addevent.sunrpc.clnt.shutdown_client.entry
	+= _addevent.sunrpc.clnt.shutdown_client.entry
{
	update_record()
}

probe _addevent.sunrpc.clnt.shutdown_client.entry
	= sunrpc.clnt.shutdown_client
{
	log_sunrpc_shutdown_client(HOOKID_SUNRPC_CLNT_SHUTDOWN_CLIENT_ENTRY,
			servername, prog, clones, tasks, rpccnt)
}

probe addevent.sunrpc.clnt.shutdown_client.return
	+= _addevent.sunrpc.clnt.shutdown_client.return
{
	update_record()
}

probe _addevent.sunrpc.clnt.shutdown_client.return
	= sunrpc.clnt.shutdown_client.return
{
	log_sunrpc_return_void(HOOKID_SUNRPC_CLNT_SHUTDOWN_CLIENT_RETURN)
}

function log_sunrpc_shutdown_client(hookid:long, servername:string, 
		prog:long, clones:long, tasks:long, rpccnt:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%2b%2b%4b", 
			THIS->servername, (_FMT_)THIS->prog, 
			(_FMT_)THIS->clones, (_FMT_)THIS->tasks, 
			(_FMT_)THIS->rpccnt);
%}

// Fires when a new RPC program is to be bound an existing client
probe addevent.sunrpc.clnt.bind_new_program.entry
	+= _addevent.sunrpc.clnt.bind_new_program.entry
{
	update_record()
}

probe _addevent.sunrpc.clnt.bind_new_program.entry
	= sunrpc.clnt.bind_new_program
{
	log_sunrpc_bind_new_program(HOOKID_SUNRPC_CLNT_BIND_NEW_PROGRAM_ENTRY, 
			servername, old_prog, old_vers, prog, vers)
}

probe addevent.sunrpc.clnt.bind_new_program.return
	+= _addevent.sunrpc.clnt.bind_new_program.return
{
	update_record()
}

probe _addevent.sunrpc.clnt.bind_new_program.return
	= sunrpc.clnt.bind_new_program.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_CLNT_BIND_NEW_PROGRAM_RETURN, 
			$return)
}

function log_sunrpc_bind_new_program(hookid:long, servername:string, 
		old_prog:long, old_vers:long, prog:long, vers:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%1b%8b%1b",
			THIS->servername, (_FMT_)THIS->old_prog, 
			(_FMT_)THIS->old_vers, (_FMT_)THIS->prog, 
			(_FMT_)THIS->vers);
%}

// rpc_call_sync
probe addevent.sunrpc.clnt.call_sync.entry
	+= _addevent.sunrpc.clnt.call_sync.entry
{
	update_record()
}

probe _addevent.sunrpc.clnt.call_sync.entry
	= sunrpc.clnt.call_sync
{
	 log_sunrpc_call_sync(HOOKID_SUNRPC_CLNT_CALL_SYNC_ENTRY, servername, 
			prog, vers, proc, flags)
}

probe addevent.sunrpc.clnt.call_sync.return
	+= _addevent.sunrpc.clnt.call_sync.return
{
	update_record()
}

probe _addevent.sunrpc.clnt.call_sync.return
	= sunrpc.clnt.call_sync.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_CLNT_CALL_SYNC_RETURN, $return)
}

function log_sunrpc_call_sync(hookid:long, servername:string, prog:long, 
		vers:long, proc:long, flags:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%1b%8b%8b",
			THIS->servername, (_FMT_)THIS->prog, 
			(_FMT_)THIS->vers, (_FMT_)THIS->proc, 
			(_FMT_)THIS->flags);
%}

// rpc_call_async
probe addevent.sunrpc.clnt.call_async.entry
	+= _addevent.sunrpc.clnt.call_async.entry
{
	update_record()
}

probe _addevent.sunrpc.clnt.call_async.entry
	= sunrpc.clnt.call_async
{
	 log_sunrpc_call_async(HOOKID_SUNRPC_CLNT_CALL_ASYNC_ENTRY, servername, 
			 prog, vers, proc, flags)
}

probe addevent.sunrpc.clnt.call_async.return
	+= _addevent.sunrpc.clnt.call_async.return
{
	update_record()
}

probe _addevent.sunrpc.clnt.call_async.return
	= sunrpc.clnt.call_async.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_CLNT_CALL_ASYNC_RETURN, $return)
}

function log_sunrpc_call_async(hookid:long, servername:string, prog:long, 
		vers:long, proc:long, flags:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%1b%8b%8b",
			THIS->servername, (_FMT_)THIS->prog, 
			(_FMT_)THIS->vers, (_FMT_)THIS->proc, 
			(_FMT_)THIS->flags);
%}

// Fires when want to restart a task
probe addevent.sunrpc.clnt.restart_call.entry
	+= _addevent.sunrpc.clnt.restart_call.entry
{
	update_record()
}

probe _addevent.sunrpc.clnt.restart_call.entry
	= sunrpc.clnt.restart_call
{
	log_sunrpc_restart_call(HOOKID_SUNRPC_CLNT_RESTART_CALL_ENTRY, tk_pid, 
			tk_flags)
} 

probe addevent.sunrpc.clnt.restart_call.return
	+= _addevent.sunrpc.clnt.restart_call.return
{
	update_record()
}

probe _addevent.sunrpc.clnt.restart_call.return
	= sunrpc.clnt.restart_call.return
{
	log_sunrpc_return_void(HOOKID_SUNRPC_CLNT_RESTART_CALL_RETURN) //void
}

function log_sunrpc_restart_call(hookid:long, tk_pid:long, tk_flags:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%8b%8b", 
			(_FMT_)THIS->tk_pid, (_FMT_)THIS->tk_flags);
%}

/*********************************************
 *    Probe points on RPC server interface   *
 ********************************************/
probe addevent.sunrpc.svc
	= addevent.sunrpc.svc.entry, addevent.sunrpc.svc.return
{}

probe addevent.sunrpc.svc.entry
	=
	addevent.sunrpc.svc.register.entry,
	addevent.sunrpc.svc.create.entry,
	addevent.sunrpc.svc.destroy.entry,
	addevent.sunrpc.svc.process.entry,
	addevent.sunrpc.svc.authorise.entry,
	addevent.sunrpc.svc.recv.entry,
	addevent.sunrpc.svc.send.entry,
	addevent.sunrpc.svc.drop.entry
{}

probe addevent.sunrpc.svc.return
	=
	addevent.sunrpc.svc.register.return,
	addevent.sunrpc.svc.create.return,
	addevent.sunrpc.svc.destroy.return,
	addevent.sunrpc.svc.process.return,
	addevent.sunrpc.svc.authorise.return,
	addevent.sunrpc.svc.recv.return,
	addevent.sunrpc.svc.send.return,
	addevent.sunrpc.svc.drop.return
{}

// Fires when an RPC service is to be registered with the local portmapper.
probe addevent.sunrpc.svc.register.entry
	+= _addevent.sunrpc.svc.register.entry
{
	update_record()
}

probe _addevent.sunrpc.svc.register.entry
	= sunrpc.svc.register
{
	log_sunrpc_svc_register(HOOKID_SUNRPC_SVC_REGISTER_ENTRY, sv_name, 
			prog, prot, port)
}

probe addevent.sunrpc.svc.register.return
	+= _addevent.sunrpc.svc.register.return
{
	update_record()
}

probe _addevent.sunrpc.svc.register.return
	= sunrpc.svc.register.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SVC_REGISTER_RETURN, 
			$return) 
}

function log_sunrpc_svc_register(hookid:long, sv_name:string,
		prog:long, prot:long, port:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%2b%4b", 
			THIS->sv_name, (_FMT_)THIS->prog, 
			(_FMT_)THIS->prot, (_FMT_)THIS->port);
%}

// Fires when an RPC service is to be created
probe addevent.sunrpc.svc.create.entry
	+= _addevent.sunrpc.svc.create.entry
{
	update_record()
}

probe _addevent.sunrpc.svc.create.entry
	= sunrpc.svc.create
{
	log_sunrpc_svc_create(HOOKID_SUNRPC_SVC_CREATE_ENTRY, prog, 
			pg_nvers, bufsize)
}

probe addevent.sunrpc.svc.create.return
	+= _addevent.sunrpc.svc.create.return
{
	update_record()
}

probe _addevent.sunrpc.svc.create.return
	= sunrpc.svc.create.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SVC_CREATE_RETURN, $return)
}

function log_sunrpc_svc_create(hookid:long, prog:long, 
		pg_nvers:long, bufsize:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%8b%1b%4b", 
			(_FMT_)THIS->prog, (_FMT_)THIS->pg_nvers,
			(_FMT_)THIS->bufsize);
%}

// Fires when an RPC service is to be destroyed
probe addevent.sunrpc.svc.destroy.entry
	+= _addevent.sunrpc.svc.destroy.entry
{
	update_record()
}

probe _addevent.sunrpc.svc.destroy.entry
	= sunrpc.svc.destroy
{
	log_sunrpc_svc_destroy(HOOKID_SUNRPC_SVC_DESTROY_ENTRY, 
			sv_name, sv_prog, sv_nrthreads)
}

probe addevent.sunrpc.svc.destroy.return
	+= _addevent.sunrpc.svc.destroy.return
{
	update_record()
}

probe _addevent.sunrpc.svc.destroy.return
	= sunrpc.svc.destroy.return
{
	log_sunrpc_return_void(HOOKID_SUNRPC_SVC_DESTROY_RETURN)
}

function log_sunrpc_svc_destroy(hookid:long, sv_name:string, 
		sv_prog:long, sv_nrthreads:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%4b", THIS->sv_name, 
			(_FMT_)THIS->sv_prog, (_FMT_)THIS->sv_nrthreads);
%}

// Fires when an RPC request is to be processed
probe addevent.sunrpc.svc.process.entry
	+= _addevent.sunrpc.svc.process.entry
{
	update_record()
}
probe _addevent.sunrpc.svc.process.entry
	= sunrpc.svc.process
{
	log_sunrpc_task_info(HOOKID_SUNRPC_SVC_PROCESS_ENTRY, sv_name, 
			sv_prog, peer_ip, rq_xid, rq_prog, rq_vers, rq_proc)
}

probe addevent.sunrpc.svc.process.return
	+= _addevent.sunrpc.svc.process.return
{
	update_record()
}

probe _addevent.sunrpc.svc.process.return
	= sunrpc.svc.process.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SVC_PROCESS_RETURN, $return)
}

// Fires when an RPC request is to be authorised
probe addevent.sunrpc.svc.authorise.entry
	+= _addevent.sunrpc.svc.authorise.entry
{
	update_record()
}

probe _addevent.sunrpc.svc.authorise.entry
	= sunrpc.svc.authorise
{
	log_sunrpc_svc_authorise(HOOKID_SUNRPC_SVC_AUTHORISE_ENTRY, sv_name, 
			peer_ip, rq_xid, rq_prog, rq_vers, rq_proc)
}

probe addevent.sunrpc.svc.authorise.return
	+= _addevent.sunrpc.svc.authorise.return
{
	update_record()
}

probe _addevent.sunrpc.svc.authorise.return
	= sunrpc.svc.authorise.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SVC_AUTHORISE_RETURN, $return)
}

function log_sunrpc_svc_authorise(hookid:long, sv_name:string, peer_ip:long, 
		rq_xid:long, rq_prog:long, rq_vers:long, rq_proc:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%8b%8b%1b%8b",
			THIS->sv_name, (_FMT_)THIS->peer_ip, 
			(_FMT_)THIS->rq_xid, (_FMT_)THIS->rq_prog, 
			(_FMT_)THIS->rq_vers, (_FMT_)THIS->rq_proc);
%}

/*
 * Fires when receiving the next request on any socket.
 */
probe addevent.sunrpc.svc.recv.entry
	+= _addevent.sunrpc.svc.recv.entry
{
	update_record()
}

probe _addevent.sunrpc.svc.recv.entry
	= sunrpc.svc.recv
{
	log_sunrpc_svc_recv(HOOKID_SUNRPC_SVC_SEND_ENTRY, sv_name, timeout)
}

probe addevent.sunrpc.svc.recv.return
	+= _addevent.sunrpc.svc.recv.return
{
	update_record()
}

probe _addevent.sunrpc.svc.recv.return
	= sunrpc.svc.recv.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SVC_SEND_RETURN, $return)
}

function log_sunrpc_svc_recv(hookid:long, sv_name:string, timeout:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b", THIS->sv_name, 
			(_FMT_)THIS->timeout);
%}

// Fires when want to return reply to client.
probe addevent.sunrpc.svc.send.entry
	+= _addevent.sunrpc.svc.send.entry
{
	update_record()
}

probe _addevent.sunrpc.svc.send.entry
	= sunrpc.svc.send
{
	log_sunrpc_svc_send(HOOKID_SUNRPC_SVC_SEND_ENTRY, sv_name, peer_ip, 
			rq_xid, rq_prog, rq_vers, rq_proc)
}

probe addevent.sunrpc.svc.send.return
	+= _addevent.sunrpc.svc.send.return
{
	update_record()
}

probe _addevent.sunrpc.svc.send.return
	= sunrpc.svc.send.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SVC_SEND_RETURN, $return)
}

function log_sunrpc_svc_send(hookid:long, sv_name:string, peer_ip:long,
		rq_xid:long, rq_prog:long, rq_vers:long, rq_proc:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%8b%8b%1b%8b", 
			THIS->sv_name, (_FMT_)THIS->peer_ip, 
			(_FMT_)THIS->rq_xid, (_FMT_)THIS->rq_prog, 
			(_FMT_)THIS->rq_vers, (_FMT_)THIS->rq_proc);
%}

// Fires when a request is to be dropped
probe addevent.sunrpc.svc.drop.entry
	+= _addevent.sunrpc.svc.drop.entry
{
	update_record()
}

probe _addevent.sunrpc.svc.drop.entry
	= sunrpc.svc.drop
{
	log_sunrpc_svc_drop(HOOKID_SUNRPC_SVC_DROP_ENTRY, sv_name, peer_ip, 
			rq_xid, rq_prog, rq_vers, rq_proc)
}

probe addevent.sunrpc.svc.drop.return
	+= _addevent.sunrpc.svc.drop.return
{
	update_record()
}

probe _addevent.sunrpc.svc.drop.return
	= sunrpc.svc.drop.return
{
	log_sunrpc_return_void(HOOKID_SUNRPC_SVC_DROP_RETURN)
}

function log_sunrpc_svc_drop(hookid:long, sv_name:string, peer_ip:long,
		rq_xid:long, rq_prog:long, rq_vers:long, rq_proc:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%8b%8b%1b%8b", 
			THIS->sv_name, (_FMT_)THIS->peer_ip, 
			(_FMT_)THIS->rq_xid, (_FMT_)THIS->rq_prog, 
			(_FMT_)THIS->rq_vers, (_FMT_)THIS->rq_proc);
%}

/*******************************************************************
 *                  Probe points on RPC scheduler                  *
 ******************************************************************/
probe addevent.sunrpc.sched
	= addevent.sunrpc.sched.entry, addevent.sunrpc.sched.return
{}

probe addevent.sunrpc.sched.entry
	= 
	addevent.sunrpc.sched.new_task.entry,
	addevent.sunrpc.sched.execute.entry,
	addevent.sunrpc.sched.delay.entry,
	addevent.sunrpc.sched.release_task.entry
{}

probe addevent.sunrpc.sched.return
	= 
	addevent.sunrpc.sched.new_task.return,
	addevent.sunrpc.sched.execute.return,
	addevent.sunrpc.sched.delay.return,
	addevent.sunrpc.sched.release_task.return
{}

// Fires when creating a new task for the specified client
probe addevent.sunrpc.sched.new_task.entry
	+= _addevent.sunrpc.sched.new_task.entry
{
	update_record()
}

probe _addevent.sunrpc.sched.new_task.entry
	= sunrpc.sched.new_task
{
	log_sunrpc_new_task(HOOKID_SUNRPC_SCHED_NEW_TASK_ENTRY, xid, prog, 
			vers, prot, flags)
}

probe addevent.sunrpc.sched.new_task.return
	+= _addevent.sunrpc.sched.new_task.return
{
	update_record()
}

probe _addevent.sunrpc.sched.new_task.return
	= sunrpc.sched.new_task.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SCHED_NEW_TASK_RETURN, $return)
}

function log_sunrpc_new_task(hookid:long, xid:long, prog:long, vers:long,
		prot:long, flags:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%8b%8b%1b%8b%8b",
			(_FMT_)THIS->xid, (_FMT_)THIS->prog,
			(_FMT_)THIS->vers, (_FMT_)THIS->prot,
			(_FMT_)THIS->flags);
%}

// Fires when releasing a task
probe addevent.sunrpc.sched.release_task.entry
	+= _addevent.sunrpc.sched.release_task.entry
{
	update_record()
}

probe _addevent.sunrpc.sched.release_task.entry
	= sunrpc.sched.release_task
{
	log_sunrpc_release_task(HOOKID_SUNRPC_SCHED_RELEASE_TASK_ENTRY,	
			xid, prog, vers, prot, tk_flags)
}

probe addevent.sunrpc.sched.release_task.return
	+= _addevent.sunrpc.sched.release_task.return
{
	update_record()
}

probe _addevent.sunrpc.sched.release_task.return
	= sunrpc.sched.release_task.return
{
	log_sunrpc_return_void(HOOKID_SUNRPC_SCHED_RELEASE_TASK_RETURN)
}

function log_sunrpc_release_task(hookid:long, xid:long, prog:long, vers:long,
		prot:long, flags:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%8b%8b%1b%8b%8b",
			(_FMT_)THIS->xid, (_FMT_)THIS->prog,
			(_FMT_)THIS->vers, (_FMT_)THIS->prot,
			(_FMT_)THIS->flags);
%}

// Fires when an RPC request is to be executed
probe addevent.sunrpc.sched.execute.entry
	+= _addevent.sunrpc.sched.execute.entry
{
	update_record()
}

probe _addevent.sunrpc.sched.execute.entry
	= sunrpc.sched.execute
{
	log_sunrpc_execute(HOOKID_SUNRPC_SCHED_EXECUTE_ENTRY, xid, prog, 
			vers, prot, tk_pid, tk_flags)
}

probe addevent.sunrpc.sched.execute.return
	+= _addevent.sunrpc.sched.execute.return
{
	update_record()
}

probe _addevent.sunrpc.sched.execute.return
	= sunrpc.sched.execute.return
{
	log_sunrpc_return_int64(HOOKID_SUNRPC_SCHED_EXECUTE_RETURN, $return)
}

function log_sunrpc_execute(hookid:long, xid:long, prog:long, vers:long,
		prot:long, tk_pid:long, tk_flags:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%8b%8b%1b%8b%8b%8b",
			(_FMT_)THIS->xid, (_FMT_)THIS->prog,
			(_FMT_)THIS->vers, (_FMT_)THIS->prot,
			(_FMT_)THIS->tk_pid, (_FMT_)THIS->tk_flags);
%}

// Fires when want to delay an RPC request
probe addevent.sunrpc.sched.delay.entry
	+= _addevent.sunrpc.sched.delay.entry
{
	update_record()
}

probe _addevent.sunrpc.sched.delay.entry
	= sunrpc.sched.delay
{
	log_sunrpc_delay(HOOKID_SUNRPC_SCHED_DELAY_ENTRY, xid, prog, 
			tk_pid, tk_flags, delay)
}

probe addevent.sunrpc.sched.delay.return
	+= _addevent.sunrpc.sched.delay.return
{
	update_record()
}

probe _addevent.sunrpc.sched.delay.return
	= sunrpc.sched.delay.return
{
	log_sunrpc_return_void(HOOKID_SUNRPC_SCHED_DELAY_RETURN)
}

function log_sunrpc_delay(hookid:long, xid:long, prog:long, tk_pid:long, 
		tk_flags:long, delay:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%8b%8b%8b%8b%8b",
			(_FMT_)THIS->xid, (_FMT_)THIS->prog,
			(_FMT_)THIS->tk_pid, (_FMT_)THIS->tk_flags,
			(_FMT_)THIS->delay);
%}

/******************************************************************
 *                       Helper functions                        *
 *****************************************************************/
function log_sunrpc_client_info(hookid:long, servername:string, 
		prog:long, vers:long, prot:long,
		port:long, authflavor:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%1b%2b%2b%1b", 
			THIS->servername, (_FMT_)THIS->prog, 
			(_FMT_)THIS->vers, (_FMT_)THIS->prot, 
			(_FMT_)THIS->port, (_FMT_)THIS->authflavor);
%}

function log_sunrpc_task_info(hookid:long, sv_name:string,
		sv_prog:long, peer_ip:long, rq_xid:long,
		rq_prog:long, rq_vers:long, rq_proc:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%0s%8b%8b%8b%8b%1b%1b",
			THIS->sv_name, (_FMT_)THIS->sv_prog, 
			(_FMT_)THIS->peer_ip, (_FMT_)THIS->rq_xid, 
			(_FMT_)THIS->rq_prog, (_FMT_)THIS->rq_vers,
			(_FMT_)THIS->rq_proc);
%}

function log_sunrpc_return_int64(hookid:long, ret:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%8b", (_FMT_)THIS->ret);
%}

function log_sunrpc_return_int32(hookid:long, ret:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%4b", (_FMT_)THIS->ret);
%}

function log_sunrpc_return_int16(hookid:long, ret:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%2b", (_FMT_)THIS->ret);
%}

function log_sunrpc_return_int8(hookid:long, ret:long)
%{
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%1b", (_FMT_)THIS->ret);
%}

function log_sunrpc_return_void(hookid:long)
%{
#define VOIDRETURN	0
	_lket_trace(_GROUP_SUNRPC, THIS->hookid, "%1b", (_FMT_)VOIDRETURN);
%}

