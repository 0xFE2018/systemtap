// Copyright (C) 2005, 2006 IBM Corp.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
#if defined(ASCII_TRACE)
#ifndef _FMT_
#define _FMT_ unsigned int
#endif
#else
#ifndef _FMT_
#define _FMT_ int64_t
#endif
#endif
%}

function lket_trace_header_init()
%{

/* header info for binary format*/
#if !defined(ASCII_TRACE) 

#define MAGIC_NUMBER           0xAEFCDB6B
#define LKET_TRACE_VER_MAJOR   0x01
#define LKET_TRACE_VER_MINOR   0x01 /* used for user customization */
#define LITTLE_ENDIAN          0x01
#define BIG_ENDIAN             0x02
#define BITS_WIDTH             64     /* 32-bit or 64-bit environment*/

#define LKET_HEADER_LEN        0   /* fake number, bin_write will fill in the
                                     actual length of trace header */

	_stp_printf("%4b%2n%1b%1b%1b%1b", (_FMT_)MAGIC_NUMBER, (_FMT_)LKET_HEADER_LEN, 
		(_FMT_)LKET_TRACE_VER_MAJOR, (_FMT_)LKET_TRACE_VER_MINOR, 
		(_FMT_)BIG_ENDIAN, (_FMT_)BITS_WIDTH);
	_stp_print_flush();
#endif

%}

function lket_trace_init() 
{
	lket_trace_header_init()
}

%{
#ifndef __LKET_TRACE__
#define __LKET_TRACE__

#define STP_BIN_PACKET 1


#define MAX_FMT_LEN 128
char newfmt[MAX_FMT_LEN] = "\n%d|%d|%d|%d|%d|%d|%d|%d";
#define NEW_FMT_START 24 

void fmt_change(char *oldfmt)
{
	char *old_ptr, *new_ptr;

	old_ptr = oldfmt;
	new_ptr = newfmt + NEW_FMT_START;

	while(*old_ptr != 0 && (new_ptr - newfmt) < MAX_FMT_LEN)  {
		if(*old_ptr != '%')  {
			*new_ptr++ = *old_ptr++;
			continue;
		}  else  {
			*new_ptr++ = '|'; /* delimier to make it readable */ 
			*new_ptr++ = *old_ptr++;
			while( *old_ptr == 'L' || *old_ptr == 'l'
				|| isdigit(*old_ptr) )  {
				*new_ptr++ = *old_ptr++;
			}
			if( *old_ptr == 'b') {
				if(isdigit(*(old_ptr-1))) {
					if(*(old_ptr-1) == '1' ||
					   *(old_ptr-1) == '2' ||
					   *(old_ptr-1) == '3' ||
					   *(old_ptr-1) == '4')  {
						new_ptr--;
					} else if(*(old_ptr-1) == '8')  {
						*--new_ptr='l';
						*++new_ptr='l';
						new_ptr++;
					}
				}
				*new_ptr++ = 'd';
				old_ptr++;
			}
			else if ( *old_ptr == 's') {
				if(isdigit(*(old_ptr-1)) && *(old_ptr-1)=='0')
					new_ptr--;
				*new_ptr++ = 's';
				old_ptr++;
			} else
				*new_ptr++ = *old_ptr++;
		}
	}
	*new_ptr=0;
}

/* trace data in ASCII format 
   Format of the common prefix of the trace data:
  groupid|subhookid|sec|usec|tgid|ppid|pid|cpuid|
*/
#if defined(ASCII_TRACE)

#define _lket_trace(GroupID, hookID, fmt, args...) do { \
	struct timeval tv; \
	do_gettimeofday (&tv); \
	fmt_change(fmt); \
	_stp_printf(newfmt, \
		(_FMT_)GroupID, (_FMT_)hookID, (_FMT_)tv.tv_sec, (_FMT_)tv.tv_usec,\
		(_FMT_)current->tgid, (_FMT_)current->parent->pid,\
		(_FMT_)current->pid, (_FMT_)current->thread_info->cpu, args);\
} while(0)

#else //binary trace

static inline int this_event_len(void)
{
	return 0;
}

/* we use 2 bytes to store the length. 256 may be not enough for backtrace event */
#define _lket_trace(GroupID, hookID, fmt, args...) do { \
	struct timeval tv; \
	do_gettimeofday (&tv); \
	_stp_printf("%1b%2n%1b%1b%4b%4b%4b%4b%4b%1b"fmt, \
		(_FMT_)STP_BIN_PACKET, (_FMT_)GroupID, (_FMT_)hookID, \
		(_FMT_)tv.tv_sec, (_FMT_)tv.tv_usec, (_FMT_)current->tgid, \
		(_FMT_)current->parent->pid, (_FMT_)current->pid, \
		(_FMT_)current->thread_info->cpu, args);\
} while(0)

#endif
#endif
%}
