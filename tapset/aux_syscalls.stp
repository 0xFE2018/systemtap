#
# Given a userspace pointer to a timeval,
# copy and decode it and return a string.
#
function _struct_timeval_u:string(uaddr:long)
%{ /* pure */
	struct timeval tv;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char*)&tv,ptr,sizeof(struct timeval)) == 0)
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%ld.%06ld]", tv.tv_sec, tv.tv_usec);
	   	else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	}
%}

function _struct_compat_timeval_u:string(uaddr:long)
%{ /* pure */
	struct compat_timeval tv;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char*)&tv,ptr,sizeof(struct compat_timeval)) == 0)
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%ld.%06ld]", (long)tv.tv_sec, (long)tv.tv_usec);
	   	else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	}
%}

function _struct_timeval:string(addr:long)
%{ /* pure */
	struct timeval *tv;
	char *ptr = (char *)(unsigned long)THIS->addr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		tv=(struct timeval *) ptr;
		snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%ld.%06ld]", tv->tv_sec, tv->tv_usec);
	}
%}

function _struct_timezone_u:string(uaddr:long)
%{ /* pure */
	struct timezone tz;
	char *ptr = (char *)(unsigned long)THIS->uaddr;
	
	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char*)&tz,ptr,sizeof(struct timezone)) == 0)
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%d, %d]", tz.tz_minuteswest, tz.tz_dsttime);
		else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	}
%} 

%{
static const int days_in_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static void _stp_ctime(time_t t, char *buf, int buflen)
{
	int mon=1, day, hour, min, sec, num, d, year = 1970;
	
	sec = t % 60; 
	min = t/60 % 60;
	hour = t/(60*60) % 24;	
	day = t/(24*60*60);

	while(1) {
		d =  (!(year % 4) && ((year % 100) || !(year % 400))) ? 366 : 365;
		if (day >= d)
			day -= d;
		else
			break;
		year++;
	}
	while (mon < 12) {
		num = days_in_month[mon-1];
		if (mon == 2 && d == 366)
			num++;
		if (day >= num)
			day -= num;
		else
			break;
		mon++;
	}
	
	snprintf(buf, buflen, "%4d/%02d/%02d-%02d:%02d:%02d", year, mon, day+1, hour, min, sec);
	buf[buflen-1] = 0;
}
%}

function _struct_utimbuf_u:string(uaddr:long)
%{ /* pure */
	#include <linux/utime.h>
	struct utimbuf ubuf;
	static char abuf[24], mbuf[24];
	char *ptr = (char *)(unsigned long)THIS->uaddr;
	
	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char*)&ubuf,ptr,sizeof(ubuf)) == 0) {
			_stp_ctime(ubuf.actime, abuf, 24);
			_stp_ctime(ubuf.modtime, mbuf, 24);
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "%s, %s", abuf, mbuf);
		} else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	}
%} 

function _struct_compat_utimbuf_u:string(uaddr:long)
%{ /* pure */
	#include <linux/utime.h>
	struct compat_utimbuf ubuf;
	static char abuf[24], mbuf[24];
	char *ptr = (char *)(unsigned long)THIS->uaddr;
	
	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char*)&ubuf,ptr,sizeof(ubuf)) == 0) {
			_stp_ctime(ubuf.actime, abuf, 24);
			_stp_ctime(ubuf.modtime, mbuf, 24);
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "%s, %s", abuf, mbuf);
		} else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	}
%} 

function _struct_timespec_u:string(uaddr:long)
%{ /* pure */
	struct timespec ts;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char *)&ts,ptr,sizeof(struct timespec)))  {
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
		} else
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%ld.%09ld]", 
				(unsigned long)ts.tv_sec, (unsigned long)ts.tv_nsec);
	}
%}
function _struct_compat_timespec_u:string(uaddr:long)
%{ /* pure */
	struct compat_timespec ts;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char *)&ts,ptr,sizeof(struct compat_timespec)))  {
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
		} else
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%ld.%09ld]", 
				(unsigned long)ts.tv_sec, (unsigned long)ts.tv_nsec);
	}
%}

function _struct_timespec:string(addr:long)
%{ /* pure */
	struct timespec *ts;
	char *ptr = (char *)(unsigned long)THIS->addr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		ts =  (struct timespec *) ptr;
		snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%ld.%09ld]", 
			(unsigned long)ts->tv_sec, (unsigned long)ts->tv_nsec);
	}
%}

function _struct_itimerspec_u:string(uaddr:long)
%{ /* pure */
	struct itimerspec its;
	char *ptr = (char *)(unsigned long)THIS->uaddr;
	
	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char *)&its, ptr,sizeof(struct itimerspec)))
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
		else
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%d.%06d,%d.%06d]",
				(int)its.it_interval.tv_sec, (int)its.it_interval.tv_nsec,
				(int)its.it_value.tv_sec, (int)its.it_value.tv_nsec);
	}	
%}

function _struct_itimerval_u:string(uaddr:long)
%{ /* pure */
	struct itimerval itv;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char *)&itv,ptr,sizeof(struct itimerval)))
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
		else
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%d.%06d,%d.%06d]", 
				(int)itv.it_interval.tv_sec, (int)itv.it_interval.tv_usec,
				(int)itv.it_value.tv_sec, (int)itv.it_value.tv_usec);
	}
%}

function _struct_compat_itimerval_u:string(uaddr:long)
%{ /* pure */
	struct compat_itimerval itv;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if(_stp_copy_from_user((char *)&itv,ptr,sizeof(struct compat_itimerval)))
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
		else
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%d.%06d,%d.%06d]", 
				(int)itv.it_interval.tv_sec, (int)itv.it_interval.tv_usec,
				(int)itv.it_value.tv_sec, (int)itv.it_value.tv_usec);
	}
%}

function _struct_itimerval:string(addr:long)
%{ /* pure */
	struct itimerval *itv;
	char *ptr = (char *)(unsigned long)THIS->addr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		itv = (struct itimerval *) ptr;
		snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%d.%06d,%d.%06d]", 
			(int)itv->it_interval.tv_sec, (int)itv->it_interval.tv_usec,
			(int)itv->it_value.tv_sec, (int)itv->it_value.tv_usec);
	}
%}

%{
#include <linux/version.h>
#include <net/sock.h>
#include <net/tcp.h>
#include <linux/socket.h>
#include <linux/un.h>

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
#define LPORT   (inet->inet.num)
#define DADDR   (&inet->inet.daddr)
#else
#define LPORT   (inet->num)
#define DADDR   (&inet->daddr)
#endif

//FIXME. Not done yet.

void _stp_sockaddr_str(char *str, const int strlen, char *buf, int len)
{
	struct sockaddr *sa = (struct sockaddr *)buf;
	switch (sa->sa_family) {
	case AF_INET: 
	{
		struct sockaddr_in *sin = (struct sockaddr_in *)buf;
		const unsigned char *addr = (unsigned char *)&sin->sin_addr;
		snprintf(str, strlen, "{AF_INET, %d.%d.%d.%d, %d}", 
			addr[0], addr[1], addr[2], addr[3], ntohs(sin->sin_port));
		break;
	}
	case AF_UNIX:
	{	
		struct sockaddr_un *sun = (struct sockaddr_un *)buf;	
		snprintf(str, strlen, "{AF_UNIX, %s}", sun->sun_path); 
		break;
	}
	case AF_NETLINK:
	{
		struct sockaddr_nl *nl = (struct sockaddr_nl *)buf;
		snprintf(str, strlen, "{AF_NETLINK, pid=%d, groups=%08x}", nl->nl_pid, nl->nl_groups); 
		break;
	}
	case AF_INET6: 
	{
		// FIXME. Address is probably not correctly displayed
		struct sockaddr_in6 *sin = (struct sockaddr_in6 *)buf;
		snprintf(str, strlen, "{AF_INET6, %016llx, %d}", 
			*(long long *)&sin->sin6_addr, ntohs(sin->sin6_port));
		break;
	}
	case AF_PACKET: 
	{
		/* FIXME. This needs tested */
		struct sockaddr_ll *sll = (struct sockaddr_ll *)buf;
#if defined(__powerpc__) || defined(__ia64__) || defined(__s390x__)
		snprintf(str, strlen, "{AF_PACKET, proto=%d, ind=%d, hatype=%d, pkttype=%d, halen=%d, addr=0x%lx}", 
			(int)sll->sll_protocol, sll->sll_ifindex, (int)sll->sll_hatype, (int)sll->sll_pkttype,
			(int)sll->sll_halen, *(uint64_t *)sll->sll_addr);
#else
		snprintf(str, strlen, "{AF_PACKET, proto=%d, ind=%d, hatype=%d, pkttype=%d, halen=%d, addr=0x%llx}", 
			(int)sll->sll_protocol, sll->sll_ifindex, (int)sll->sll_hatype, (int)sll->sll_pkttype,
			(int)sll->sll_halen, *(uint64_t *)sll->sll_addr);
#endif
		break;
	}

	default:
		snprintf(str, strlen, "{unknown address family %d}", sa->sa_family);	
	}
}
%}

function _struct_sockaddr_u:string(uaddr:long, len:long)
%{ /* pure */
	char *ptr = (char *)(unsigned long)THIS->uaddr;
	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		char buf[128];
		size_t len = THIS->len < 128 ? THIS->len : 128;
		if(_stp_copy_from_user(buf, ptr, len))
			strlcpy (THIS->__retvalue, "[...]", MAXSTRINGLEN);
		else
			_stp_sockaddr_str(THIS->__retvalue, MAXSTRINGLEN, buf, len);
	}
%}

function _signal_name:string(sig:long)
%{ /* pure */
  	int sig = THIS->sig;
	char *res = 0;

	switch(sig) {
	case 0:
		res = "NO_SIGNAL";
		break;
	case SIGHUP:
		res = "SIGHUP";
		break;
	case SIGINT:
		res = "SIGINT";
		break;
	case SIGQUIT:
		res = "SIGQUIT";
		break;
	case SIGILL:
		res = "SIGILL";
		break;
	case SIGTRAP:
		res = "SIGTRAP";
		break;
	case SIGABRT:
		res = "SIGABRT";
		break;
	case SIGBUS:
		res = "SIGBUS";
		break;
	case SIGFPE:
		res = "SIGFPE";
		break;
	case SIGKILL:
		res = "SIGKILL";
		break;
	case SIGUSR1:
		res = "SIGUSR1";
		break;
	case SIGSEGV:
		res = "SIGSEGV";
		break;
	case SIGPIPE:
		res = "SIGPIPE";
		break;
	case SIGUSR2:
		res = "SIGUSR2";
		break;
	case SIGALRM:
		res = "SIGALRM";
		break;
	case SIGTERM:
		res = "SIGTERM";
		break;
	case SIGCHLD:
		res = "SIGCHLD";
		break;
	case SIGCONT:
		res = "SIGCONT";
		break;
	case SIGSTOP:
		res = "SIGSTOP";
		break;
	case SIGTSTP:
		res = "SIGTSTP";
		break;
	case SIGTTIN:
		res = "SIGTTIN";
		break;
	case SIGTTOU:
		res = "SIGTTOU";
		break;
	case SIGURG:
		res = "SIGURG";
		break;
	case SIGPROF:
		res = "SIGPROF";
		break;
	case SIGWINCH:
		res = "SIGWINCH";
		break;
	case SIGVTALRM:
		res = "SIGVTALRM";
		break;
	case SIGIO:
		res = "SIGIO/SIGPOLL";
		break;
	case SIGPWR:
		res = "SIGPWR";
		break;
	}
	if (res)
		strlcpy (THIS->__retvalue, res, MAXSTRINGLEN);
	else
		snprintf(THIS->__retvalue, MAXSTRINGLEN, "%d", sig);
%}

function _struct_rlimit_u:string(uaddr:long)
%{ /* pure */
	struct rlimit rl;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if (_stp_copy_from_user((char *)&rl, ptr, sizeof(struct rlimit)) == 0)
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%ld,%ld]",
				rl.rlim_cur, rl.rlim_max);
		else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	}
%}

function _fildes_u:string (uaddr:long)
%{ /* pure */
	int fd[2];
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if (_stp_copy_from_user((char *)&fd, ptr, 2*sizeof(int)) == 0)
			 snprintf(THIS->__retvalue, MAXSTRINGLEN, "[%d, %d]", fd[0], fd[1]);
		else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	}
%}

function _fd_set_u:string(uaddr:long)
%{ /* pure */
	fd_set fdset;
	char *ptr = (char *)(unsigned long)THIS->uaddr;

	if (ptr == NULL)
		strlcpy (THIS->__retvalue, "NULL", MAXSTRINGLEN);
	else {
		if (_stp_copy_from_user((char *)&fdset, ptr, sizeof(fd_set)) == 0)
			snprintf(THIS->__retvalue, MAXSTRINGLEN, "[0x%lx, 0x%lx, ...]", (long) fdset.fds_bits[0],  fdset.fds_bits[1]);
		else
			strlcpy (THIS->__retvalue, "UNKNOWN", MAXSTRINGLEN);
	} 
%}


function _semctl_cmd:string(cmd:long)
%{ /* pure */
	int cmd = THIS->cmd;
	char *res = 0;

	switch(cmd) {
		case IPC_INFO:
			res = "IPC_INFO";
			break;
		case SEM_INFO:
			res = "SEM_INFO";
			break;
		case SEM_STAT:
			res = "SEM_STAT";
			break;
		case GETALL:
			res = "GETALL";
			break;
		case GETVAL:
			res = "GETVAL";
			break;
		case GETPID:
			res = "GETPID";
			break;
		case GETNCNT:
			res = "GETNCNT";
			break;
		case GETZCNT:
			res = "GETZCNT";
			break;
		case IPC_STAT:
			res = "IPC_STAT";
			break;
		case SETVAL:
			res = "SETVAL";
			break;
		case SETALL:
			res = "SETALL";
			break;
		case IPC_RMID:
			res = "IPC_RMID";
			break;
		case IPC_SET:
			res = "IPC_SET";
			break;
	}
	if (res)
		strlcpy (THIS->__retvalue, res, MAXSTRINGLEN);
	else
		snprintf(THIS->__retvalue, MAXSTRINGLEN, "%d", cmd);	
%}

function __sem_flags:string(semflg:long)
%{ /* pure */
	long semflg = THIS->semflg;
	char *str = THIS->__retvalue;

	if (semflg & IPC_CREAT)
		strlcat(str, "IPC_CREAT|", MAXSTRINGLEN);
	if (semflg & IPC_EXCL)
		strlcat(str, "IPC_EXCL|", MAXSTRINGLEN);

	str[strlen(str)-1] = 0;
%}

function __fork_flags:string(flags:long)
%{ /* pure */
	int len;
  	long flags = THIS->flags;
	char *str = THIS->__retvalue;
	if (flags & CLONE_FS)
		strlcat(str,"CLONE_FS|", MAXSTRINGLEN);
	if (flags & CLONE_FILES)
		strlcat(str, "CLONE_FILES|", MAXSTRINGLEN);
	if (flags & CLONE_SIGHAND)
		strlcat(str, "CLONE_SIGHAND|", MAXSTRINGLEN);
	if (flags & CLONE_PTRACE)
		strlcat(str, "CLONE_PTRACE|", MAXSTRINGLEN);
	if (flags & CLONE_VFORK)
		strlcat(str, "CLONE_VFORK|", MAXSTRINGLEN);
	if (flags & CLONE_PARENT)
		strlcat(str, "CLONE_PARENT|", MAXSTRINGLEN);
	if (flags & CLONE_THREAD)
		strlcat(str, "CLONE_THREAD|", MAXSTRINGLEN);
	if (flags & CLONE_SYSVSEM)
		strlcat(str, "CLONE_SYSVSEM|", MAXSTRINGLEN);
	if (flags & CLONE_SETTLS)
		strlcat(str, "CLONE_SETTLS|", MAXSTRINGLEN);
	if (flags & CLONE_PARENT_SETTID)
		strlcat(str, "CLONE_PARENT_SETTID|", MAXSTRINGLEN);
	if (flags & CLONE_CHILD_CLEARTID)
		strlcat(str, "CLONE_CHILD_CLEARTID|", MAXSTRINGLEN);
	if (flags & CLONE_UNTRACED)
		strlcat(str, "CLONE_UNTRACED|", MAXSTRINGLEN);
	if (flags & CLONE_CHILD_SETTID)
		strlcat(str, "CLONE_CHILD_SETTID|", MAXSTRINGLEN);
	if (flags & CLONE_STOPPED)
		strlcat(str, "CLONE_STOPPED|", MAXSTRINGLEN);
	len = strlen(str);
	if (len)
		str[strlen(str)-1] = 0;
%}

/* This function copies an argv from userspace. */
function __get_argv:string(a:long)
%{ /* pure */
  	char __user *__user *argv = (char __user *__user *)(long)THIS->a;
	char __user *vstr;
	int space, rc, len = MAXSTRINGLEN;
	char *str = THIS->__retvalue;
	char buf[80];
	char *ptr = buf;

	if (argv)
		argv++;

	while (argv != NULL) {
		if (get_user (vstr, argv))
      			break;

		if (vstr == NULL)
			break;

		rc = _stp_strncpy_from_user(buf, vstr, 79);
		if (rc <= 0)
			break;

		/* check for whitespace in string */
		buf[rc] = 0;
		ptr = buf;
		space = 0;
		while (*ptr && rc--) {
			if (isspace(*ptr++)) {
				space = 1;
				break;
			}
		}

		if (len != MAXSTRINGLEN && len) {
			*str++=' ';
			len--;
		}

		if (space && len) {
			*str++='\"';
			len--;
		}
	
		rc = strlcpy (str, buf, len); 
		str += rc;
		len -= rc;

		if (space && len) {
			*str++='\"';
			len--;
		}

		argv++;
	}
	*str = 0;
%}

/*
* This function is used when a long is really a pointer and we need
* the string it points to. Should be rarely necessary.
*/
function __string:string (a:long)
%{ /* pure */
	char *str =(char *)(long)THIS->a;
	strlcpy(THIS->__retvalue, str, MAXSTRINGLEN);
%}

/*
 * Return a integer member value of struct
 * timezone user  space pointer  parameter
 * CALLERS:
 *    syscall.gettimeofday
 *    syscall.settimeofday
 */
/*
function __uget_tz_m:long(u_addr:long,member:long)
%{
   struct timezone tz;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct timezone);

   if(copy_from_user(&tz,ptr,sz))
      THIS->__retvalue = -EFAULT;
   else if(THIS->member == 0)
      THIS->__retvalue = tz.tz_minuteswest;
   else
      THIS->__retvalue = tz.tz_dsttime;
%}
*/
/*
 * Return integer member value of struct
 * timex user  space  pointer  parameter
 * CALLERS:
 *    syscall.adjtimex
 */
/*
function __uget_timex_m:long(u_addr:long,member:long)
%{
   struct timex tx;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct timex);

   if(copy_from_user(&tx,ptr,sz)) {
      THIS->__retvalue = -EFAULT;
      return;
   }
   switch(THIS->member) {
      case 0:  THIS->__retvalue =  tx.modes;
               break;
      case 1:  THIS->__retvalue =  tx.offset;
               break;
      case 2:  THIS->__retvalue =  tx.freq;
               break;
      case 3:  THIS->__retvalue =  tx.maxerror;
               break;
      case 4:  THIS->__retvalue =  tx.esterror;
               break;
      case 5:  THIS->__retvalue =  tx.status;
               break;
      case 6:  THIS->__retvalue =  tx.constant;
               break;
      case 7:  THIS->__retvalue =  tx.precision;
               break;
      case 8:  THIS->__retvalue =  tx.tolerance;
               break;
      case 9:  THIS->__retvalue =  tx.time.tv_sec;
               break;
      case 10: THIS->__retvalue = tx.time.tv_usec;
               break;
      case 11: THIS->__retvalue = tx.tick;
               break;
      default: THIS->__retvalue = -1;
   }
%}
*/
/*
 * Return the clock_t member  value of the
 * struct tms user space pointer parameter
 * CALLERS:
 *    syscall.times
 */
/*
%{ #include <linux/times.h> %}
function __uget_tms_m:long(u_addr:long,member:long)
%{
   struct tms tms;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct tms);

   if(copy_from_user(&tms,ptr,sz))
      THIS->__retvalue = -EFAULT;
   switch(THIS->member) {
      case 0:  THIS->__retvalue =  tms.tms_utime;
               break;
      case 1:  THIS->__retvalue =  tms.tms_stime;
               break;
      case 2:  THIS->__retvalue =  tms.tms_cutime;
               break;
      case 3:  THIS->__retvalue =  tms.tms_cstime;
               break;
      default: THIS->__retvalue = -1;
   }
%}
*/
/*
 * Return a time_t / long  member  value of the
 * struct timespec user space pointer parameter
 * CALLERS:
 *    syscall.nanosleep
 */
/*
function __uget_ts_m:long(u_addr:long,member:long)
%{
   struct timespec ts;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct timespec);

   if(copy_from_user(&ts,ptr,sz))
      THIS->__retvalue = -EFAULT;
   else if(THIS->member == 0)
      THIS->__retvalue = ts.tv_sec;
   else
      THIS->__retvalue = ts.tv_nsec;
%}
*/

/*
 * Return the  symbolic string  representation
 * of the struct timex.mode member of adjtimex
 * consult `man adjtimex` for more information
 * CALLERS:
 *    syscall.adjtimex
 */
function _adjtx_mode_str(f) {
   if((f & 32769) == 32769) bs="ADJ_OFFSET_SINGLESHOT|".bs
   if(f  & 16384) bs="ADJ_TICK|".bs
   if(f  & 32)    bs="ADJ_TIMECONST|".bs
   if(f  & 16)    bs="ADJ_STATUS|".bs
   if(f  & 8)     bs="ADJ_ESTERROR|".bs
   if(f  & 4)     bs="ADJ_MAXERROR|".bs
   if(f  & 2)     bs="ADJ_FREQUENCY|".bs
   if(f & 1 && ((f & 32769) != 32769)) bs="ADJ_OFFSET|".bs
   return substr(bs,0,strlen(bs)-1)
}

/*
 * Return the symbolic string representation
 * of the how argument given in *sigprocmask
 * consult  `man sigprocmask`  for more info
 * CALLERS:
 *    syscall.sigprocmask
 *    syscall.rt_sigprocmask
 */
function _sigprocmask_how_str(how) {
   if(how==0) return "SIG_BLOCK"
   if(how==1) return "SIG_UNBLOCK"
   if(how==2) return "SIG_SETMASK"
   return ""
}

/*
 * Return the symbolic string representation
 * of the which argument  given to setitimer
 * consult  `man setitimer`  for  more  info
 * CALLERS:
 *    syscall.getitimer
 *    syscall.setitimer
 */
function _itimer_which_str(which) {
   if(which==0) return "ITIMER_REAL"
   if(which==1) return "ITIMER_VIRTUAL"
   if(which==2) return "ITIMER_PROF"
   return ""
}

/*
 * Return  the  symbolic   string  representation
 * of the clockid argument  given to create_timer
 * consult  `man create_timer`  for  more  info
 * CALLERS:
 *    syscall.timer_create
 *    syscall.clock_settime
 *    syscall.clock_gettime
 *    syscall.clock_getres
 *    syscall.clock_nanosleep
 */
function _get_wc_str(wc) {
   if(wc==0) return "CLOCK_REALTIME"
   if(wc==1) return "CLOCK_MONOTONIC"
   if(wc==2) return "CLOCK_PROCESS_CPUTIME_ID"
   if(wc==3) return "CLOCK_THREAD_CPUTIME_ID"
   if(wc==4) return "CLOCK_REALTIME_HR"
   if(wc==5) return "CLOCK_MONOTONIC_HR"
   return ""
}

function _flock_cmd_str(c) {
   if(c & 1) bs="LOCK_SH|".bs
   if(c & 2) bs="LOCK_EX|".bs
   if(c & 8) bs="LOCK_UN|".bs
   if(c & 4) bs="LOCK_NB|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man 2 open` for more information */
function _sys_open_flag_str:string (f:long)
%{ /* pure */
	int flags = (int)THIS->f;
	int acc = flags & O_ACCMODE;

	switch (acc) {
	case O_WRONLY:
		strlcpy (THIS->__retvalue, "O_WRONLY", MAXSTRINGLEN);
		break;
	case O_RDWR:
		strlcpy (THIS->__retvalue, "O_RDWR", MAXSTRINGLEN);
		break;
	default:
		strlcpy (THIS->__retvalue, "O_RDONLY", MAXSTRINGLEN);
	}

#ifdef O_APPEND
	if (flags & O_APPEND)
		strlcat (THIS->__retvalue, "|O_APPEND", MAXSTRINGLEN);
#endif
#ifdef O_CREAT
	if (flags & O_CREAT)
		strlcat (THIS->__retvalue, "|O_CREAT", MAXSTRINGLEN);
#endif
#ifdef O_ASYNC
	if (flags & O_ASYNC)
		strlcat (THIS->__retvalue, "|O_ASYNC", MAXSTRINGLEN);
#endif
#ifdef O_DIRECT
	if (flags & O_DIRECT)
		strlcat (THIS->__retvalue, "|O_DIRECT", MAXSTRINGLEN);
#endif
#ifdef O_DIRECTORY
	if (flags & O_DIRECTORY)
		strlcat (THIS->__retvalue, "|O_DIRECTORY", MAXSTRINGLEN);
#endif
#ifdef O_EXCL
	if (flags & O_EXCL)
		strlcat (THIS->__retvalue, "|O_EXCL", MAXSTRINGLEN);
#endif
#ifdef O_LARGEFILE
	if (flags & O_LARGEFILE)
		strlcat (THIS->__retvalue, "|O_LARGEFILE", MAXSTRINGLEN);
#endif
#ifdef O_NOATIME
	if (flags & O_NOATIME)
		strlcat (THIS->__retvalue, "|O_NOATIME", MAXSTRINGLEN);
#endif
#ifdef O_NOCTTY
	if (flags & O_NOCTTY)
		strlcat (THIS->__retvalue, "|O_NOCTTY", MAXSTRINGLEN);
#endif
#ifdef O_NOFOLLOW
	if (flags & O_NOFOLLOW)
		strlcat (THIS->__retvalue, "|O_NOFOLLOW", MAXSTRINGLEN);
#endif
#ifdef O_NONBLOCK
	if (flags & O_NONBLOCK)
		strlcat (THIS->__retvalue, "|O_NONBLOCK", MAXSTRINGLEN);
#endif
#ifdef O_SYNC
	if (flags & O_SYNC)
		strlcat (THIS->__retvalue, "|O_SYNC", MAXSTRINGLEN);
#endif
#ifdef O_TRUNC
	if (flags & O_TRUNC)
		strlcat (THIS->__retvalue, "|O_TRUNC", MAXSTRINGLEN);
#endif
%}


/* `man 2 open` for more information */
function _access_mode_str(m) {
	if((m & 7) == 0) return "F_OK"	
	if(m & 4) bs="R_OK |".bs
	if(m & 2) bs="W_OK |".bs
	if(m & 1) bs="X_OK |".bs
	return substr(bs,0,strlen(bs)-2)
}

/* `man 2 open` for more information */
function _sys_open_mode_str(f) {
   if((f & 448) == 448) bs="S_IRWXU|".bs
   else {
        if(f & 256) bs="S_IRUSR|".bs
        if(f & 128) bs="S_IWUSR|".bs
        if(f & 64) bs="S_IXUSR|".bs
   }
   if((f & 56) == 56) bs="S_IRWXG|".bs
   else {
        if(f & 32) bs="S_IRGRP|".bs
        if(f & 16) bs="S_IWGRP|".bs
        if(f & 8) bs="S_IXGRP|".bs
   }
   if((f & 7) == 7) bs="S_IRWXO|".bs
   else {
        if(f & 4) bs="S_IROTH|".bs
        if(f & 2) bs="S_IWOTH|".bs
        if(f & 1) bs="S_IXOTH|".bs
   }
   return substr(bs,0,strlen(bs)-1)
}

/* `man 2 mknod` for more information */
function _mknod_mode_str(mode) {
   if((mode & 0x8000)==0x8000)
        return "S_IFREG|"._sys_open_mode_str(mode)
   if((mode & 0x2000)==0x2000)
        return "S_IFCHR|"._sys_open_mode_str(mode)
   if((mode & 0x6000)==0x6000)
        return "S_IFBLK|"._sys_open_mode_str(mode)
   if((mode & 0x1000)==0x1000)
        return "S_IFIFO|"._sys_open_mode_str(mode)
   if((mode & 0xC000)==0xC000)
        return "S_IFSOCK|"._sys_open_mode_str(mode)
   return ""
}

/* `man msync` for more information */
function _msync_flag_str(f) {
	if (f & 7 == 0) return ""
	if(f & 4) bs="MS_SYNC|".bs
	if(f & 2) bs="MS_INVALIDATE|".bs
	if(f & 1) bs="MS_ASYNC|".bs
	return substr(bs,0,strlen(bs)-1)
}

/* `man wait4` for more information */
function _wait4_opt_str(f) {
   if(f & 0x01000000) bs="WNOWAIT|".bs
   if(f & 8) bs="WCONTINUED|".bs
   if(f & 4) bs="WEXITED|".bs
   if(f & 2) bs="WSTOPPED|".bs
   if(f & 1) bs="WNOHANG|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man sendmsg` for more information */
function _send_flags_str(f) {
   if(f & 0x0001) bs="MSG_OOB|".bs
   if(f & 0x0080) bs="MSG_EOR|".bs
   if(f & 0x0004) bs="MSG_DONTROUTE|".bs
   if(f & 0x0040) bs="MSG_DONTWAIT|".bs
   if(f & 0x4000) bs="MSG_NOSIGNAL|".bs
   if(f & 0x0800) bs="MSG_CONFIRM|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man recv` for more information */
function _recvflags_str(f) {
   if(f & 1) bs="MSG_OOB|".bs
   if(f & 2) bs="MSG_PEEK|".bs
   if(f & 32) bs="MSG_TRUNC|".bs
   if(f & 256) bs="MSG_WAITALL|".bs
   if(f & 8192) bs="MSG_ERRQUEUE|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man mlockall` for more information */
function _mlockall_flags_str(f) {
   if(f & 1) bs="MCL_CURRENT|".bs
   if(f & 2) bs="MCL_FUTURE|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* used by sys_delete_module */
function _module_flags_str(f) {	
   if(!(f & 2048)) bs="WAIT|"
   if(f & 512) bs=bs."FORCE|"
   return substr(bs,0,strlen(bs)-1)
}

function _sched_policy_str(policy) {
   if(policy==0) return "SCHED_OTHER"
   if(policy==1) return "SCHED_FIFO"
   if(policy==2) return "SCHED_RR"
   return ""
}

function _priority_which_str(which) {
   if(which==0) return "PRIO_PROCESS"
   if(which==1) return "PRIO_PGRP"
   if(which==2) return "PRIO_USER"
   return ""
}

function _shutdown_how_str(how) {
   if(how==0) return "SHUT_RD"
   if(how==1) return "SHUT_WR"
   if(how==2) return "SHUT_RDWR"
   return ""
}

function _reboot_magic_str(magic) {
   if(magic==0xFEE1DEAD) return "LINUX_REBOOT_MAGIC1"
   if(magic==672274793)  return "LINUX_REBOOT_MAGIC2"
   if(magic==85072278)   return "LINUX_REBOOT_MAGIC2A"
   if(magic==369367448)  return "LINUX_REBOOT_MAGIC2B"
   if(magic==537993216)  return "LINUX_REBOOT_MAGIC2C"
   return ""
}

function _reboot_flag_str(flag) {
   if(flag==0x01234567) return "LINUX_REBOOT_CMD_RESTART"
   if(flag==0xCDEF0123) return "LINUX_REBOOT_CMD_HALT"
   if(flag==0x4321FEDC) return "LINUX_REBOOT_CMD_POWER_OFF"
   if(flag==0xA1B2C3D4) return "LINUX_REBOOT_CMD_RESTART2"
   if(flag==0x89ABCDEF) return "LINUX_REBOOT_CMD_CAD_ON"
   if(flag==0x00000000) return "LINUX_REBOOT_CMD_CAD_OFF"
   return ""
}

function _waitid_which_str(flag) {
   if(flag==0) return "P_ALL"
   if(flag==1) return "P_PID"
   if(flag==2) return "P_PGID"
   return ""
}

function _futex_op_str(op) {
   if(op==0) return "FUTEX_WAIT"
   if(op==1) return "FUTEX_WAKE"
   if(op==2) return "FUTEX_FD"
   if(op==3) return "FUTEX_REQUEUE"
   if(op==4) return "FUTEX_CMP_REQUEUE"
   return ""
}

function _mountflags_str:string(op:long) 
%{ /* pure */
	int len, op = THIS->op;
	char *str = THIS->__retvalue;
	if (op & MS_BIND)
		strlcat(str,"MS_BIND|",MAXSTRINGLEN);
	if (op & MS_DIRSYNC)
		strlcat(str,"MS_DIRSYNC|",MAXSTRINGLEN);
	if (op & MS_MANDLOCK)
		strlcat(str,"MS_MANDLOCK|",MAXSTRINGLEN);
	if (op & MS_MOVE)
		strlcat(str,"MS_MOVE|",MAXSTRINGLEN);
	if (op & MS_NOATIME)
		strlcat(str,"MS_NOATIME|",MAXSTRINGLEN);
	if (op & MS_NODEV)
		strlcat(str,"MS_NODEV|",MAXSTRINGLEN);
	if (op & MS_NODIRATIME)
		strlcat(str,"MS_NODIRATIME|",MAXSTRINGLEN);
	if (op & MS_NOEXEC)
		strlcat(str,"MS_NOEXEC|",MAXSTRINGLEN);
	if (op & MS_NOSUID)
		strlcat(str,"MS_NOSUID|",MAXSTRINGLEN);
	if (op & MS_RDONLY)
		strlcat(str,"MS_RDONLY|",MAXSTRINGLEN);
	if (op & MS_REC)
		strlcat(str,"MS_REC|",MAXSTRINGLEN);
	if (op & MS_REMOUNT)
		strlcat(str,"MS_REMOUNT|",MAXSTRINGLEN);
	if (op & MS_SYNCHRONOUS)
		strlcat(str,"MS_SYNCHRONOUS|",MAXSTRINGLEN);
	if (op & MS_VERBOSE)
		strlcat(str,"MS_VERBOSE|",MAXSTRINGLEN);
	len = strlen(str);
	if (len)
		str[strlen(str)-1] = 0;
%}

function _umountflags_str:string(op:long) 
%{ /* pure */
	int len, op = THIS->op;
	char *str = THIS->__retvalue;
	if (op == 0)
		strlcat(str,"0",MAXSTRINGLEN);
	else {
		if (op & MNT_FORCE)
			strlcat(str,"MNT_FORCE|",MAXSTRINGLEN);
		if (op & MNT_DETACH)
			strlcat(str,"MNT_DETACH|",MAXSTRINGLEN);
		if (op & MNT_EXPIRE)
			strlcat(str,"MNT_EXPIRE|",MAXSTRINGLEN);
		len = strlen(str);
		if (len)
			str[strlen(str)-1] = 0;
	}
%}

function _statfs_f_type_str(f) {
   if(f==0xadf5)     return "ADFS_SUPER_MAGIC"
   if(f==0xADFF)     return "AFFS_SUPER_MAGIC"
   if(f==0x42465331) return "BEFS_SUPER_MAGIC"
   if(f==0x1BADFACE) return "BFS_MAGIC"
   if(f==0xFF534D42) return "CIFS_MAGIC_NUMBER"
   if(f==0x73757245) return "CODA_SUPER_MAGIC"
   if(f==0x012FF7B7) return "COH_SUPER_MAGIC"
   if(f==0x28cd3d45) return "CRAMFS_MAGIC"
   if(f==0x1373)     return "DEVFS_SUPER_MAGIC"
   if(f==0x00414A53) return "EFS_SUPER_MAGIC"
   if(f==0x137D)     return "EXT_SUPER_MAGIC"
   if(f==0xEF51)     return "EXT2_OLD_SUPER_MAGIC"
   if(f==0xEF53)     return "EXT2_SUPER_MAGIC"
   if(f==0xEF53)     return "EXT3_SUPER_MAGIC"
   if(f==0x4244)     return "HFS_SUPER_MAGIC"
   if(f==0xF995E849) return "HPFS_SUPER_MAGIC"
   if(f==0x958458f6) return "HUGETLBFS_MAGIC"
   if(f==0x9660)     return "ISOFS_SUPER_MAGIC"
   if(f==0x72b6)     return "JFFS2_SUPER_MAGIC"
   if(f==0x3153464a) return "JFS_SUPER_MAGIC"
   if(f==0x137F)     return "MINIX_SUPER_MAGIC"
   if(f==0x138F)     return "MINIX_SUPER_MAGIC2"
   if(f==0x2468)     return "MINIX2_SUPER_MAGIC"
   if(f==0x2478)     return "MINIX2_SUPER_MAGIC2"
   if(f==0x4d44)     return "MSDOS_SUPER_MAGIC"
   if(f==0x564c)     return "NCP_SUPER_MAGIC"
   if(f==0x6969)     return "NFS_SUPER_MAGIC"
   if(f==0x5346544e) return "NTFS_SB_MAGIC"
   if(f==0x9fa1)     return "OPENPROM_SUPER_MAGIC"
   if(f==0x9fa0)     return "PROC_SUPER_MAGIC"
   if(f==0x002f)     return "QNX4_SUPER_MAGIC"
   if(f==0x52654973) return "REISERFS_SUPER_MAGIC"
   if(f==0x7275)     return "ROMFS_MAGIC"
   if(f==0x517B)     return "SMB_SUPER_MAGIC"
   if(f==0x012FF7B6) return "SYSV2_SUPER_MAGIC"
   if(f==0x012FF7B5) return "SYSV4_SUPER_MAGIC"
   if(f==0x01021994) return "TMPFS_MAGIC"
   if(f==0x15013346) return "UDF_SUPER_MAGIC"
   if(f==0x00011954) return "UFS_MAGIC"
   if(f==0x9fa2)     return "USBDEVICE_SUPER_MAGIC"
   if(f==0xa501FCF5) return "VXFS_SUPER_MAGIC"
   if(f==0x012FF7B4) return "XENIX_SUPER_MAGIC"
   if(f==0x58465342) return "XFS_SUPER_MAGIC"
   if(f==0x012FD16D) return "_XIAFS_SUPER_MAGIC"
   return ""
}

function _mmap_flags(flags) {
	if (flags & 1) msg="MAP_SHARED|"
	if (flags & 2) msg="MAP_PRIVATE|".msg
	if (flags & 0x10) msg="MAP_FIXED|".msg
	if (flags & 0x20) msg="MAP_ANONYMOUS|".msg
	if (flags & 0x100) msg="MAP_GROWSDOWN|".msg
	if (flags & 0x800) msg="MAP_DENYWRITE|".msg
	if (flags & 0x1000) msg="MAP_EXECUTABLE|".msg
	if (flags & 0x2000) msg="MAP_LOCKED|".msg
	if (flags & 0x4000) msg="MAP_NORESERVE|".msg
	if (flags & 0x8000) msg="MAP_POPULATE|".msg
	if (flags & 0x10000) msg="MAP_NONBLOCK|".msg
	return substr(msg,0,strlen(msg)-1)
}

function _mprotect_prot_str(prot) {
	if (prot) {
		if(prot & 1) ps="PROT_READ|"
		if(prot & 2) ps="PROT_WRITE|".ps
		if(prot & 4) ps="PROT_EXEC|".ps
		return substr(ps,0,strlen(ps)-1)	
	}
	return "PROT_NONE"
}

function _madvice_advice_str(behavior) {
   if(behavior==0x00000000) return "MADV_NORMAL"
   if(behavior==0x00000001) return "MADV_RANDOM"
   if(behavior==0x00000002) return "MADV_SEQUENTIAL"
   if(behavior==0x00000003) return "MADV_WILLNEED"
   if(behavior==0x00000004) return "MADV_DONTNEED"
   return ""
}

function _fadvice_advice_str(behavior) {
   if(behavior==0x00000000) return "FADV_NORMAL"
   if(behavior==0x00000001) return "FADV_RANDOM"
   if(behavior==0x00000002) return "FADV_SEQUENTIAL"
   if(behavior==0x00000003) return "FADV_WILLNEED"
   if(behavior==0x00000004) return "FADV_DONTNEED"
   return ""
}

function _fcntl_cmd_str(cmd) {
   if(cmd==0x00000000) return "F_DUPFD"
   if(cmd==0x00000001) return "F_GETFD"
   if(cmd==0x00000002) return "F_SETFD"
   if(cmd==0x00000003) return "F_GETFL"
   if(cmd==0x00000004) return "F_SETFL"
   if(cmd==0x00000005) return "F_GETLK"
   if(cmd==0x00000006) return "F_SETLK"
   if(cmd==0x00000007) return "F_SETLKW"
   if(cmd==0x00000008) return "F_SETOWN"
   if(cmd==0x00000009) return "F_GETOWN"
   if(cmd==0x0000000A) return "F_SETSIG"
   if(cmd==0x0000000B) return "F_GETLK64"
   if(cmd==0x0000000C) return "F_SETLK64"
   if(cmd==0x0000000D) return "F_SETLKW64"
   return ""
}

function _seek_whence_str(w) {
   if(w==0x00000000) return "SEEK_SET"
   if(w==0x00000001) return "SEEK_CUR"
   if(w==0x00000002) return "SEEK_END"
   return ""
}

function _quotactl_cmd_str(cmd) {
   if(cmd==0x800002) return "Q_QUOTAON"
   if(cmd==0x800003) return "Q_QUOTAOFF"
   if(cmd==0x800007) return "Q_GETQUOTA"
   if(cmd==0x800008) return "Q_SETQUOTA"
   if(cmd==0x800005) return "Q_GETINFO"
   if(cmd==0x800006) return "Q_SETINFO"
   if(cmd==0x800004) return "Q_GETFMT"
   if(cmd==0x800001) return "Q_SYNC"
   /* XFS Quota Manager (XQM) Codes */
   if(cmd==0x5801) return "Q_XQUOTAON"
   if(cmd==0x5802) return "Q_XQUOTAOFF"
   if(cmd==0x5803) return "Q_XGETQUOTA"
   if(cmd==0x5804) return "Q_XSETQLIM"
   if(cmd==0x5805) return "Q_XGETQSTAT"
   if(cmd==0x5806) return "Q_XQUOTARM"
   return ""
}

/* see sys/socket.h (for setsockopt) */
function _sockopt_optname_str(opt) {
   if(opt==1) return "SO_DEBUG"
   if(opt==2) return "SO_REUSEADDR"
   if(opt==3) return "SO_TYPE"
   if(opt==4) return "SO_ERROR"
   if(opt==5) return "SO_DONTROUTE"
   if(opt==6) return "SO_BROADCAST"
   if(opt==7) return "SO_SNDBUF"
   if(opt==8) return "SO_RCVBUF"
   if(opt==9) return "SO_KEEPALIVE"
   if(opt==10) return "SO_OOBINLINE"
   if(opt==11) return "SO_NO_CHECK"
   if(opt==12) return "SO_PRIORITY"
   if(opt==13) return "SO_LINGER"
   if(opt==14) return "SO_BSDCOMPAT"

   if(opt==16) return "SO_PASSCRED"
   if(opt==17) return "SO_PEERCRED"
   if(opt==18) return "SO_RCVLOWAT"
   if(opt==19) return "SO_SNDLOWAT"
   if(opt==20) return "SO_RCVTIMEO"
   if(opt==21) return "SO_SNDTIMEO"
   return ""
}

/* `man 2 setsockopt` for more information */
function _sockopt_level_str(l) {
   if(l==0) return "IP"
   if(l==1) return "ICMP"
   if(l==2) return "IGMP"
   if(l==3) return "GGP"
   if(l==4) return "IP-ENCAP"
   if(l==5) return "ST"
   if(l==6) return "TCP"
   if(l==7) return "CBT"
   if(l==8) return "EGP"
   if(l==9) return "IGP"
   if(l==10) return "BBN-RCC-MON"
   if(l==11) return "NVP-II"
   if(l==12) return "PUP"
   if(l==13) return "ARGUS"
   if(l==14) return "EMCON"
   if(l==15) return "XNET"
   if(l==16) return "CHAOS"
   if(l==17) return "UDP"
   if(l==18) return "MUX"
   if(l==19) return "DCN-MEAS"
   if(l==20) return "HMP"
   if(l==21) return "PRM"
   if(l==22) return "XNS-IDP"
   if(l==23) return "TRUNK-1"
   if(l==24) return "TRUNK-2"
   if(l==25) return "LEAF-1"
   if(l==26) return "LEAF-2"
   if(l==27) return "RDP"
   if(l==28) return "IRTP"
   if(l==29) return "ISO-TP4"
   if(l==30) return "NETBLT"
   if(l==31) return "MFE-NSP"
   if(l==32) return "MERIT-INP"
   if(l==33) return "SEP"
   if(l==34) return "3PC"
   if(l==35) return "IDPR"
   if(l==36) return "XTP"
   if(l==37) return "DDP"
   if(l==38) return "IDPR-CMTP"
   if(l==39) return "TP++"
   if(l==40) return "IL"
   if(l==41) return "IPv6"
   if(l==42) return "SDRP"
   if(l==43) return "IPv6-Route"
   if(l==44) return "IPv6-Frag"
   if(l==45) return "IDRP"
   if(l==46) return "RSVP"
   if(l==47) return "GRE"
   if(l==48) return "MHRP"
   if(l==49) return "BNA"
   if(l==50) return "IPv6-Crypt"
   if(l==51) return "IPv6-Auth"
   if(l==52) return "I-NLSP"
   if(l==53) return "SWIPE"
   if(l==54) return "NARP"
   if(l==55) return "MOBILE"
   if(l==56) return "TLSP"
   if(l==57) return "SKIP"
   if(l==58) return "IPv6-ICMP"
   if(l==59) return "IPv6-NoNxt"
   if(l==60) return "IPv6-Opts"
   if(l==62) return "CFTP"
   if(l==64) return "SAT-EXPAK"
   if(l==65) return "KRYPTOLAN"
   if(l==66) return "RVD"
   if(l==67) return "IPPC"
   if(l==69) return "SAT-MON"
   if(l==70) return "VISA"
   if(l==71) return "IPCV"
   if(l==72) return "CPNX"
   if(l==73) return "CPHB"
   if(l==74) return "WSN"
   if(l==75) return "PVP"
   if(l==76) return "BR-SAT-MON"
   if(l==77) return "SUN-ND"
   if(l==78) return "WB-MON"
   if(l==79) return "WB-EXPAK"
   if(l==80) return "ISO-IP"
   if(l==81) return "VMTP"
   if(l==82) return "SECURE-VMTP"
   if(l==83) return "VINES"
   if(l==84) return "TTP"
   if(l==85) return "NSFNET-IGP"
   if(l==86) return "DGP"
   if(l==87) return "TCF"
   if(l==88) return "EIGRP"
   if(l==89) return "OSPFIGP"
   if(l==90) return "Sprite-RPC"
   if(l==91) return "LARP"
   if(l==92) return "MTP"
   if(l==93) return "AX.25"
   if(l==94) return "IPIP"
   if(l==95) return "MICP"
   if(l==96) return "SCC-SP"
   if(l==97) return "ETHERIP"
   if(l==98) return "ENCAP"
   if(l==100) return "GMTP"
   if(l==101) return "IFMP"
   if(l==102) return "PNNI"
   if(l==103) return "PIM"
   if(l==104) return "ARIS"
   if(l==105) return "SCPS"
   if(l==106) return "QNX"
   if(l==107) return "A/N"
   if(l==108) return "IPComp"
   if(l==109) return "SNP"
   if(l==110) return "Compaq-Peer"
   if(l==111) return "IPX-in-IP"
   if(l==112) return "VRRP"
   if(l==113) return "PGM"
   if(l==115) return "L2TP"
   if(l==116) return "DDX"
   if(l==117) return "IATP"
   if(l==118) return "STP"
   if(l==119) return "SRP"
   if(l==120) return "UTI"
   if(l==121) return "SMP"
   if(l==122) return "SM"
   if(l==123) return "PTP"
   if(l==124) return "ISIS"
   if(l==125) return "FIRE"
   if(l==126) return "CRTP"
   if(l==127) return "CRUDP"
   if(l==128) return "SSCOPMCE"
   if(l==129) return "IPLT"
   if(l==130) return "SPS"
   if(l==131) return "PIPE"
   if(l==132) return "SCTP"
   if(l==133) return "FC"
   return ""
}

function _sock_family_str(f) {
   if(f==0) return "PF_UNSPEC"
   if(f==1) return "PF_UNIX"
   if(f==1) return "PF_LOCAL"
   if(f==2) return "PF_INET"
   if(f==3) return "PF_AX25"
   if(f==4) return "PF_IPX"
   if(f==5) return "PF_APPLETALK"
   if(f==6) return "PF_NETROM"
   if(f==7) return "PF_BRIDGE"
   if(f==8) return "PF_ATMPVC"
   if(f==9) return "PF_X25"
   if(f==10) return "PF_INET6"
   if(f==11) return "PF_ROSE"
   if(f==12) return "PF_DECnet"
   if(f==13) return "PF_NETBEUI"
   if(f==14) return "PF_SECURITY"
   if(f==15) return "PF_KEY"
   if(f==16) return "PF_NETLINK"
   if(f==17) return "PF_PACKET"
   if(f==18) return "PF_ASH"
   if(f==19) return "PF_ECONET"
   if(f==20) return "PF_ATMSVC"
   if(f==22) return "PF_SNA"
   if(f==23) return "PF_IRDA"
   if(f==24) return "PF_PPPOX"
   if(f==25) return "PF_WANPIPE"
   if(f==26) return "PF_LLC"
   if(f==31) return "PF_BLUETOOTH"
   if(f==32) return "PF_MAX"
   return ""
}

function _sock_type_str(t) {
   if(t==1) return "SOCK_STREAM"
   if(t==2) return "SOCK_DGRAM"
   if(t==5) return "SOCK_SEQPACKET"
   if(t==3) return "SOCK_RAW"
   if(t==4) return "SOCK_RDM"
   if(t==10) return "SOCK_PACKET"
   return ""
}

function _opoll_op_str(o) {
   if(o==1) return "EPOLL_CTL_ADD"
   if(o==3) return "EPOLL_CTL_MOD"
   if(o==2) return "EPOLL_CTL_DEL"
   return ""
}

function _epoll_events_str(e) {
   if(e==1) return "EPOLLIN"
   if(e==4) return "EPOLLOUT"
   if(e==2) return "EPOLLPRI"
   if(e==8) return "EPOLLERR"
   if(e==16) return "EPOLLHUP"
   if(e==-2147483648) return "EPOLLET"
   if(e==1073741824) return "EPOLLONESHOT"
   return ""
}

function _rlimit_resource_str(r) {
   if(r==-1) return "RLIM_INFINITY"
   if(r==9) return "RLIMIT_AS"
   if(r==4) return "RLIMIT_CORE"
   if(r==0) return "RLIMIT_CPU"
   if(r==2) return "RLIMIT_DATA"
   if(r==1) return "RLIMIT_FSIZE"
   if(r==10) return "RLIMIT_LOCKS"
   if(r==8) return "RLIMIT_MEMLOCK"
   if(r==7) return "RLIMIT_NOFILE"
   if(r==6) return "RLIMIT_NPROC"
   if(r==5) return "RLIMIT_RSS"
   if(r==3) return "RLIMIT_STACK"
   return ""
}

function _rusage_who_str(w) {
   if(w==0) return "RUSAGE_SELF"
   if(w==-1) return "RUSAGE_CHILDREN"
   return ""
}

/* for accessing 16-bit values encoded in a long */
function __short:long(val:long) %{ /* pure */
	THIS->__retvalue = (short)THIS->val;
%}


/* uid_t is unsigned, but calling functions take "-1" as a paremeter */
/* so this hack is necessary to correct that mismatch. */
function __uid:long(val:long) %{ /* pure */
	THIS->__retvalue = (int)THIS->val;
%}

