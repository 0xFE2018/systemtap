/*
 * Return the 64 bit long value of the
 * scalar user space pointer parameter
 * CALLERS:
 *    kernel.syscall.time
 *    kernel.syscall.stime
 */
/*
function __uget_num:long(u_addr:long)
%{
   long long val = 0;
   if(get_user(val,
     (unsigned long *)(unsigned long)THIS->u_addr))
   {
      THIS->__retvalue = -EFAULT;
   } else
      THIS->__retvalue = val;
%}
*/
/*
 * Return a time_t/subseconds_t  member value of
 * struct timeval user space  pointer  parameter
 * CALLERS:
 *    kernel.syscall.gettimeofday
 *    kernel.syscall.settimeofday
 */
/*
function __uget_tv_m:long(u_addr:long,member:long)
%{
   struct timeval tv;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct timeval);

   if(copy_from_user(&tv,ptr,sz))
      THIS->__retvalue = -EFAULT;
   else if(THIS->member == 0)
      THIS->__retvalue = tv.tv_sec;
   else
      THIS->__retvalue = tv.tv_usec;
%}
*/
/*
 * Return  a time_t / subseconds_t  member  value  of
 * one of the struct timevals in the struct itimerval
 * user space pointer parameter
 * CALLERS:
 *    kernel.syscall.getitimer
 *    kernel.syscall.setitimer
 */
/*
function __uget_itimerval_tv_m:long(u_addr:long,member:long)
%{
   struct itimerval itv;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct itimerval);

   if(copy_from_user(&itv,ptr,sz)) {
      THIS->__retvalue = -EFAULT;
      return;
   }
   switch(THIS->member) {
      case 0:  THIS->__retvalue = itv.it_interval.tv_sec;
               break;
      case 1:  THIS->__retvalue = itv.it_interval.tv_usec;
               break;
      case 2:  THIS->__retvalue = itv.it_value.tv_sec;
               break;
      case 3:  THIS->__retvalue = itv.it_value.tv_usec;
               break;
      default: THIS->__retvalue = -1;
   }
%}
*/
/*
 * Return a integer member value of struct
 * timezone user  space pointer  parameter
 * CALLERS:
 *    kernel.syscall.gettimeofday
 *    kernel.syscall.settimeofday
 */
/*
function __uget_tz_m:long(u_addr:long,member:long)
%{
   struct timezone tz;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct timezone);

   if(copy_from_user(&tz,ptr,sz))
      THIS->__retvalue = -EFAULT;
   else if(THIS->member == 0)
      THIS->__retvalue = tz.tz_minuteswest;
   else
      THIS->__retvalue = tz.tz_dsttime;
%}
*/
/*
 * Return integer member value of struct
 * timex user  space  pointer  parameter
 * CALLERS:
 *    kernel.syscall.adjtimex
 */
/*
function __uget_timex_m:long(u_addr:long,member:long)
%{
   struct timex tx;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct timex);

   if(copy_from_user(&tx,ptr,sz)) {
      THIS->__retvalue = -EFAULT;
      return;
   }
   switch(THIS->member) {
      case 0:  THIS->__retvalue =  tx.modes;
               break;
      case 1:  THIS->__retvalue =  tx.offset;
               break;
      case 2:  THIS->__retvalue =  tx.freq;
               break;
      case 3:  THIS->__retvalue =  tx.maxerror;
               break;
      case 4:  THIS->__retvalue =  tx.esterror;
               break;
      case 5:  THIS->__retvalue =  tx.status;
               break;
      case 6:  THIS->__retvalue =  tx.constant;
               break;
      case 7:  THIS->__retvalue =  tx.precision;
               break;
      case 8:  THIS->__retvalue =  tx.tolerance;
               break;
      case 9:  THIS->__retvalue =  tx.time.tv_sec;
               break;
      case 10: THIS->__retvalue = tx.time.tv_usec;
               break;
      case 11: THIS->__retvalue = tx.tick;
               break;
      default: THIS->__retvalue = -1;
   }
%}
*/
/*
 * Return the clock_t member  value of the
 * struct tms user space pointer parameter
 * CALLERS:
 *    kernel.syscall.times
 */
/*
%{ #include <linux/times.h> %}
function __uget_tms_m:long(u_addr:long,member:long)
%{
   struct tms tms;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct tms);

   if(copy_from_user(&tms,ptr,sz))
      THIS->__retvalue = -EFAULT;
   switch(THIS->member) {
      case 0:  THIS->__retvalue =  tms.tms_utime;
               break;
      case 1:  THIS->__retvalue =  tms.tms_stime;
               break;
      case 2:  THIS->__retvalue =  tms.tms_cutime;
               break;
      case 3:  THIS->__retvalue =  tms.tms_cstime;
               break;
      default: THIS->__retvalue = -1;
   }
%}
*/
/*
 * Return a time_t / long  member  value of the
 * struct timespec user space pointer parameter
 * CALLERS:
 *    kernel.syscall.nanosleep
 */
/*
function __uget_ts_m:long(u_addr:long,member:long)
%{
   struct timespec ts;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct timespec);

   if(copy_from_user(&ts,ptr,sz))
      THIS->__retvalue = -EFAULT;
   else if(THIS->member == 0)
      THIS->__retvalue = ts.tv_sec;
   else
      THIS->__retvalue = ts.tv_nsec;
%}
*/
/*
 * Return a time_t / long  member  value of the
 * struct timespecs  in  struct itimerspec user
 * space pointer  parameter
 * CALLERS:
 *    kernel.syscall.timer_gettime
 */
/*
function __uget_itimerspec_ts_m:long(u_addr:long,member:long)
%{
   struct itimerspec its;
   char *ptr = (char *)(unsigned long)THIS->u_addr;
   size_t sz = sizeof(struct itimerspec);

   if(copy_from_user(&its,ptr,sz)) {
      THIS->__retvalue = -EFAULT;
      return;
   }
   switch(THIS->member) {
      case 0:  THIS->__retvalue =  its.it_interval.tv_sec;
               break;
      case 1:  THIS->__retvalue =  its.it_interval.tv_nsec;
               break;
      case 2:  THIS->__retvalue =  its.it_value.tv_sec;
               break;
      case 3:  THIS->__retvalue =  its.it_value.tv_nsec;
               break;
      default: THIS->__retvalue = -1;
   }
%}
*/
/*
 * Return the  symbolic string  representation
 * of the struct timex.mode member of adjtimex
 * consult `man adjtimex` for more information
 * CALLERS:
 *    kernel.syscall.adjtimex
 */
function _adjtx_mode_str(f) {
   if((f & 32769) == 32769) bs="ADJ_OFFSET_SINGLESHOT|".bs
   if(f  & 16384) bs="ADJ_TICK|".bs
   if(f  & 32)    bs="ADJ_TIMECONST|".bs
   if(f  & 16)    bs="ADJ_STATUS|".bs
   if(f  & 8)     bs="ADJ_ESTERROR|".bs
   if(f  & 4)     bs="ADJ_MAXERROR|".bs
   if(f  & 2)     bs="ADJ_FREQUENCY|".bs
   if(f & 1 && ((f & 32769) != 32769)) bs="ADJ_OFFSET|".bs
   return substr(bs,0,strlen(bs)-1)
}

/*
 * Return the symbolic string representation
 * of the how argument given in *sigprocmask
 * consult  `man sigprocmask`  for more info
 * CALLERS:
 *    kernel.syscall.sigprocmask
 *    kernel.syscall.rt_sigprocmask
 */
function _sigprocmask_how_str(how) {
   if(how==0) return "SIG_BLOCK"
   if(how==1) return "SIG_UNBLOCK"
   if(how==2) return "SIG_SETMASK"
   return ""
}

/*
 * Return the symbolic string representation
 * of the which argument  given to setitimer
 * consult  `man setitimer`  for  more  info
 * CALLERS:
 *    kernel.syscall.getitimer
 *    kernel.syscall.setitimer
 */
function _itimer_which_str(which) {
   if(which==0) return "ITIMER_REAL"
   if(which==1) return "ITIMER_VIRTUAL"
   if(which==2) return "ITIMER_PROF"
   return ""
}

/*
 * Return  the  symbolic   string  representation
 * of the clockid argument  given to create_timer
 * consult  `man create_timer`  for  more  info
 * CALLERS:
 *    kernel.syscall.timer_create
 *    kernel.syscall.clock_settime
 *    kernel.syscall.clock_gettime
 *    kernel.syscall.clock_getres
 *    kernel.syscall.clock_nanosleep
 */
function _get_wc_str(wc) {
   if(wc==0) return "CLOCK_REALTIME"
   if(wc==1) return "CLOCK_MONOTONIC"
   if(wc==2) return "CLOCK_PROCESS_CPUTIME_ID"
   if(wc==3) return "CLOCK_THREAD_CPUTIME_ID"
   if(wc==4) return "CLOCK_REALTIME_HR"
   if(wc==5) return "CLOCK_MONOTONIC_HR"
   return ""
}

function _flock_cmd_str(c) {
   if(c & 1) bs="LOCK_SH|".bs
   if(c & 2) bs="LOCK_EX|".bs
   if(c & 8) bs="LOCK_UN|".bs
   if(c & 4) bs="LOCK_NB|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man 2 open` for more information */
function _sys_open_flag_str(f) {
   if(f & 8192) bs="O_ASYNC|".bs
   if(f & 4096) bs="O_SYNC|".bs
   if(f & 2048) bs="O_NONBLOCK|".bs
   if(f & 1024) bs="O_APPEND|".bs
   if(f & 512)  bs="O_TRUNC|".bs
   if(f & 256)  bs="O_NDCTTY|".bs
   if(f & 128)  bs="O_EXCL|".bs
   if(f & 64)   bs="O_CREAT|".bs
   if((f & 3) == 2) bs="O_RDWR|".bs
   else if((f & 3) == 1) bs="O_WRONLY|".bs
   else if((f & 3) == 0) bs="O_RDONLY|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man 2 open` for more information */
function _access_mode_str(m) {
   if(m & 4) bs="R_OK|".bs
   if(m & 2) bs="W_OK|".bs
   if(m & 1) bs="X_OK|".bs
   if((m & 3) == 0) bs="F_OK|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man 2 open` for more information */
function _sys_open_mode_str(f) {
   if((f & 448) == 448) bs="S_IRWXU|".bs
   else {
        if(f & 256) bs="S_IRUSR|".bs
        if(f & 128) bs="S_IWUSR|".bs
        if(f & 64) bs="S_IXUSR|".bs
   }
   if((f & 56) == 56) bs="S_IRWXG|".bs
   else {
        if(f & 32) bs="S_IRGRP|".bs
        if(f & 16) bs="S_IWGRP|".bs
        if(f & 8) bs="S_IXGRP|".bs
   }
   if((f & 7) == 7) bs="S_IRWXO|".bs
   else {
        if(f & 4) bs="S_IROTH|".bs
        if(f & 2) bs="S_IWOTH|".bs
        if(f & 1) bs="S_IXOTH|".bs
   }
   return substr(bs,0,strlen(bs)-1)
}

/* `man 2 mknod` for more information */
function _mknod_mode_str(mode) {
   if((mode & 0x8000)==0x8000)
        return "S_IFREG|"._sys_open_mode_str(mode)
   if((mode & 0x2000)==0x2000)
        return "S_IFCHR|"._sys_open_mode_str(mode)
   if((mode & 0x6000)==0x6000)
        return "S_IFBLK|"._sys_open_mode_str(mode)
   if((mode & 0x1000)==0x1000)
        return "S_IFIFO|"._sys_open_mode_str(mode)
   if((mode & 0xC000)==0xC000)
        return "S_IFSOCK|"._sys_open_mode_str(mode)
   return ""
}

/* `man msync` for more information */
function _wait4_opt_str(f) {
   if(f & 4) bs="MS_SYNC|".bs
   if(f & 2) bs="MS_INVALIDATE|".bs
   if(f & 1) bs="MS_ASYNC|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man wait4` for more information */
function _msync_flag_str(f) {
   if(f & 0x01000000) bs="WNOWAIT|".bs
   if(f & 8) bs="WCONTINUED|".bs
   if(f & 4) bs="WEXITED|".bs
   if(f & 2) bs="WSTOPPED|".bs
   if(f & 1) bs="WNOHANG|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man sendmsg` for more information */
function _send_flags_str(f) {
   if(f & 0x0001) bs="MSG_OOB|".bs
   if(f & 0x0080) bs="MSG_EOR|".bs
   if(f & 0x0004) bs="MSG_DONTROUTE|".bs
   if(f & 0x0040) bs="MSG_DONTWAIT|".bs
   if(f & 0x4000) bs="MSG_NOSIGNAL|".bs
   if(f & 0x0800) bs="MSG_CONFIRM|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man recv` for more information */
function _recvflags_str(f) {
   if(f & 1) bs="MSG_OOB|".bs
   if(f & 2) bs="MSG_PEEK|".bs
   if(f & 32) bs="MSG_WAITALL|".bs
   if(f & 256) bs="MSG_TRUNC|".bs
   if(f & 8192) bs="MSG_ERRQUEUE|".bs
   return substr(bs,0,strlen(bs)-1)
}

/* `man mlockall` for more information */
function _mlockall_flags_str(f) {
   if(f & 2) bs="MCL_CURRENT|".bs
   if(f & 1) bs="MCL_FUTURE|".bs
   return substr(bs,0,strlen(bs)-1)
}

/*
 * The following functions return the symbolic string
 * representation of the flag. If the argument doesnt
 * map to string, an empty string ("") is returned.
 */

function _module_flags_str(f) {
   if(f==8192) return "O_ASYNC"
   if(f==4096) return "O_SYNC"
   if(f==2048) return "O_NONBLOCK"
   if(f==1024) return "O_APPEND"
   if(f==512)  return "O_TRUNC"
   if(f==256)  return "O_NDCTTY"
   if(f==128)  return "O_EXCL"
   if(f==64)   return "O_CREAT"
   if(f==2)    return "O_RDWR"
   if(f==1)    return "O_WRONLY"
   if(f==0)    return "O_RDONLY"
   return ""
}

function _sched_policy_str(policy) {
   if(policy==0) return "SCHED_OTHER"
   if(policy==1) return "SCHED_FIFO"
   if(policy==2) return "SCHED_RR"
   return ""
}

function _priority_which_str(which) {
   if(which==0) return "PRIO_PROCESS"
   if(which==1) return "PRIO_PGRP"
   if(which==2) return "PRIO_USER"
   return ""
}

function _shutdown_how_str(how) {
   if(how==0) return "SHUT_RD"
   if(how==1) return "SHUT_WR"
   if(how==2) return "SHUT_RDWR"
   return ""
}

function _reboot_magic_str(magic) {
   if(magic==0xFEE1DEAD) return "LINUX_REBOOT_MAGIC1"
   if(magic==672274793)  return "LINUX_REBOOT_MAGIC2"
   if(magic==85072278)   return "LINUX_REBOOT_MAGIC2A"
   if(magic==369367448)  return "LINUX_REBOOT_MAGIC2B"
   if(magic==537993216)  return "LINUX_REBOOT_MAGIC2C"
   return ""
}

function _reboot_flag_str(flag) {
   if(flag==0x01234567) return "LINUX_REBOOT_CMD_RESTART"
   if(flag==0xCDEF0123) return "LINUX_REBOOT_CMD_HALT"
   if(flag==0x4321FEDC) return "LINUX_REBOOT_CMD_POWER_OFF"
   if(flag==0xA1B2C3D4) return "LINUX_REBOOT_CMD_RESTART2"
   if(flag==0x89ABCDEF) return "LINUX_REBOOT_CMD_CAD_ON"
   if(flag==0x00000000) return "LINUX_REBOOT_CMD_CAD_OFF"
   return ""
}

function _waitid_which_str(flag) {
   if(flag==0) return "P_ALL"
   if(flag==1) return "P_PID"
   if(flag==2) return "P_PGID"
   return ""
}

function _futex_op_str(op) {
   if(op==0) return "FUTEX_WAIT"
   if(op==1) return "FUTEX_WAKE"
   if(op==2) return "FUTEX_FD"
   if(op==3) return "FUTEX_REQUEUE"
   if(op==4) return "FUTEX_CMP_REQUEUE"
   return ""
}

function _mountflags_str(op) {
   if(op==1)    return "MS_RDONLY"
   if(op==2)    return "MS_NOSUID"
   if(op==4)    return "MS_NODEV"
   if(op==8)    return "MS_NOEXEC"
   if(op==16)   return "MS_SYNCHRONOUS"
   if(op==32)   return "MS_REMOUNT"
   if(op==64)   return "MS_MANDLOCK"
   if(op==128)  return "S_WRITE"
   if(op==256)  return "S_APPEND"
   if(op==512)  return "S_IMMUTABLE"
   if(op==1024) return "MS_NOATIME"
   if(op==2048) return "MS_NODIRATIME"
   if(op==4096) return "MS_BIND"
   return ""
}

function _statfs_f_type_str(f) {
   if(f==0xadf5)     return "ADFS_SUPER_MAGIC"
   if(f==0xADFF)     return "AFFS_SUPER_MAGIC"
   if(f==0x42465331) return "BEFS_SUPER_MAGIC"
   if(f==0x1BADFACE) return "BFS_MAGIC"
   if(f==0xFF534D42) return "CIFS_MAGIC_NUMBER"
   if(f==0x73757245) return "CODA_SUPER_MAGIC"
   if(f==0x012FF7B7) return "COH_SUPER_MAGIC"
   if(f==0x28cd3d45) return "CRAMFS_MAGIC"
   if(f==0x1373)     return "DEVFS_SUPER_MAGIC"
   if(f==0x00414A53) return "EFS_SUPER_MAGIC"
   if(f==0x137D)     return "EXT_SUPER_MAGIC"
   if(f==0xEF51)     return "EXT2_OLD_SUPER_MAGIC"
   if(f==0xEF53)     return "EXT2_SUPER_MAGIC"
   if(f==0xEF53)     return "EXT3_SUPER_MAGIC"
   if(f==0x4244)     return "HFS_SUPER_MAGIC"
   if(f==0xF995E849) return "HPFS_SUPER_MAGIC"
   if(f==0x958458f6) return "HUGETLBFS_MAGIC"
   if(f==0x9660)     return "ISOFS_SUPER_MAGIC"
   if(f==0x72b6)     return "JFFS2_SUPER_MAGIC"
   if(f==0x3153464a) return "JFS_SUPER_MAGIC"
   if(f==0x137F)     return "MINIX_SUPER_MAGIC"
   if(f==0x138F)     return "MINIX_SUPER_MAGIC2"
   if(f==0x2468)     return "MINIX2_SUPER_MAGIC"
   if(f==0x2478)     return "MINIX2_SUPER_MAGIC2"
   if(f==0x4d44)     return "MSDOS_SUPER_MAGIC"
   if(f==0x564c)     return "NCP_SUPER_MAGIC"
   if(f==0x6969)     return "NFS_SUPER_MAGIC"
   if(f==0x5346544e) return "NTFS_SB_MAGIC"
   if(f==0x9fa1)     return "OPENPROM_SUPER_MAGIC"
   if(f==0x9fa0)     return "PROC_SUPER_MAGIC"
   if(f==0x002f)     return "QNX4_SUPER_MAGIC"
   if(f==0x52654973) return "REISERFS_SUPER_MAGIC"
   if(f==0x7275)     return "ROMFS_MAGIC"
   if(f==0x517B)     return "SMB_SUPER_MAGIC"
   if(f==0x012FF7B6) return "SYSV2_SUPER_MAGIC"
   if(f==0x012FF7B5) return "SYSV4_SUPER_MAGIC"
   if(f==0x01021994) return "TMPFS_MAGIC"
   if(f==0x15013346) return "UDF_SUPER_MAGIC"
   if(f==0x00011954) return "UFS_MAGIC"
   if(f==0x9fa2)     return "USBDEVICE_SUPER_MAGIC"
   if(f==0xa501FCF5) return "VXFS_SUPER_MAGIC"
   if(f==0x012FF7B4) return "XENIX_SUPER_MAGIC"
   if(f==0x58465342) return "XFS_SUPER_MAGIC"
   if(f==0x012FD16D) return "_XIAFS_SUPER_MAGIC"
   return ""
}

function _mprotect_prot_str(prot) {
   if(prot==0x00000000) return "PROT_NONE"
   if(prot==0x00000001) return "PROT_READ"
   if(prot==0x00000002) return "PROT_WRITE"
   if(prot==0x00000004) return "PROT_EXEC"
   return ""
}

function _madvice_advice_str(behavior) {
   if(behavior==0x00000000) return "MADV_NORMAL"
   if(behavior==0x00000001) return "MADV_RANDOM"
   if(behavior==0x00000002) return "MADV_SEQUENTIAL"
   if(behavior==0x00000003) return "MADV_WILLNEED"
   if(behavior==0x00000004) return "MADV_DONTNEED"
   return ""
}

function _fcntl_cmd_str(cmd) {
   if(cmd==0x00000000) return "F_DUPFD"
   if(cmd==0x00000001) return "F_GETFD"
   if(cmd==0x00000002) return "F_SETFD"
   if(cmd==0x00000003) return "F_GETFL"
   if(cmd==0x00000004) return "F_SETFL"
   if(cmd==0x00000005) return "F_GETLK"
   if(cmd==0x00000006) return "F_SETLK"
   if(cmd==0x00000007) return "F_SETLKW"
   if(cmd==0x00000008) return "F_SETOWN"
   if(cmd==0x00000009) return "F_GETOWN"
   if(cmd==0x0000000A) return "F_SETSIG"
   if(cmd==0x0000000B) return "F_GETLK64"
   if(cmd==0x0000000C) return "F_SETLK64"
   if(cmd==0x0000000D) return "F_SETLKW64"
   return ""
}

function _seek_whence_str(w) {
   if(w==0x00000000) return "SEEK_SET"
   if(w==0x00000001) return "SEEK_CUR"
   if(w==0x00000002) return "SEEK_END"
   return ""
}

function _quotactl_cmd_str(cmd) {
   if(cmd==0x800002) return "Q_QUOTAON"
   if(cmd==0x800003) return "Q_QUOTAOFF"
   if(cmd==0x800007) return "Q_GETQUOTA"
   if(cmd==0x800008) return "Q_SETQUOTA"
   if(cmd==0x800005) return "Q_GETINFO"
   if(cmd==0x800006) return "Q_SETINFO"
   if(cmd==0x800004) return "Q_GETFMT"
   if(cmd==0x800001) return "Q_SYNC"
   /* XFS Quota Manager (XQM) Codes */
   if(cmd==0x5801) return "Q_XQUOTAON"
   if(cmd==0x5802) return "Q_XQUOTAOFF"
   if(cmd==0x5803) return "Q_XGETQUOTA"
   if(cmd==0x5804) return "Q_XSETQLIM"
   if(cmd==0x5805) return "Q_XGETQSTAT"
   if(cmd==0x5806) return "Q_XQUOTARM"
   return ""
}

/* see sys/socket.h (for setsockopt) */
function _sockopt_optname_str(opt) {
   if(opt==1) return "SO_DEBUG"
   if(opt==2) return "SO_REUSEADDR"
   if(opt==3) return "SO_TYPE"
   if(opt==4) return "SO_ERROR"
   if(opt==5) return "SO_DONTROUTE"
   if(opt==6) return "SO_BROADCAST"
   if(opt==7) return "SO_SNDBUF"
   if(opt==8) return "SO_RCVBUF"
   if(opt==9) return "SO_KEEPALIVE"
   if(opt==10) return "SO_OOBINLINE"
   if(opt==11) return "SO_NO_CHECK"
   if(opt==12) return "SO_PRIORITY"
   if(opt==13) return "SO_LINGER"
   if(opt==14) return "SO_BSDCOMPAT"

   if(opt==16) return "SO_PASSCRED"
   if(opt==17) return "SO_PEERCRED"
   if(opt==18) return "SO_RCVLOWAT"
   if(opt==19) return "SO_SNDLOWAT"
   if(opt==20) return "SO_RCVTIMEO"
   if(opt==21) return "SO_SNDTIMEO"
   return ""
}

/* `man 2 setsockopt` for more information */
function _sockopt_level_str(l) {
   if(l==0) return "IP"
   if(l==1) return "ICMP"
   if(l==2) return "IGMP"
   if(l==3) return "GGP"
   if(l==4) return "IP-ENCAP"
   if(l==5) return "ST"
   if(l==6) return "TCP"
   if(l==7) return "CBT"
   if(l==8) return "EGP"
   if(l==9) return "IGP"
   if(l==10) return "BBN-RCC-MON"
   if(l==11) return "NVP-II"
   if(l==12) return "PUP"
   if(l==13) return "ARGUS"
   if(l==14) return "EMCON"
   if(l==15) return "XNET"
   if(l==16) return "CHAOS"
   if(l==17) return "UDP"
   if(l==18) return "MUX"
   if(l==19) return "DCN-MEAS"
   if(l==20) return "HMP"
   if(l==21) return "PRM"
   if(l==22) return "XNS-IDP"
   if(l==23) return "TRUNK-1"
   if(l==24) return "TRUNK-2"
   if(l==25) return "LEAF-1"
   if(l==26) return "LEAF-2"
   if(l==27) return "RDP"
   if(l==28) return "IRTP"
   if(l==29) return "ISO-TP4"
   if(l==30) return "NETBLT"
   if(l==31) return "MFE-NSP"
   if(l==32) return "MERIT-INP"
   if(l==33) return "SEP"
   if(l==34) return "3PC"
   if(l==35) return "IDPR"
   if(l==36) return "XTP"
   if(l==37) return "DDP"
   if(l==38) return "IDPR-CMTP"
   if(l==39) return "TP++"
   if(l==40) return "IL"
   if(l==41) return "IPv6"
   if(l==42) return "SDRP"
   if(l==43) return "IPv6-Route"
   if(l==44) return "IPv6-Frag"
   if(l==45) return "IDRP"
   if(l==46) return "RSVP"
   if(l==47) return "GRE"
   if(l==48) return "MHRP"
   if(l==49) return "BNA"
   if(l==50) return "IPv6-Crypt"
   if(l==51) return "IPv6-Auth"
   if(l==52) return "I-NLSP"
   if(l==53) return "SWIPE"
   if(l==54) return "NARP"
   if(l==55) return "MOBILE"
   if(l==56) return "TLSP"
   if(l==57) return "SKIP"
   if(l==58) return "IPv6-ICMP"
   if(l==59) return "IPv6-NoNxt"
   if(l==60) return "IPv6-Opts"
   if(l==62) return "CFTP"
   if(l==64) return "SAT-EXPAK"
   if(l==65) return "KRYPTOLAN"
   if(l==66) return "RVD"
   if(l==67) return "IPPC"
   if(l==69) return "SAT-MON"
   if(l==70) return "VISA"
   if(l==71) return "IPCV"
   if(l==72) return "CPNX"
   if(l==73) return "CPHB"
   if(l==74) return "WSN"
   if(l==75) return "PVP"
   if(l==76) return "BR-SAT-MON"
   if(l==77) return "SUN-ND"
   if(l==78) return "WB-MON"
   if(l==79) return "WB-EXPAK"
   if(l==80) return "ISO-IP"
   if(l==81) return "VMTP"
   if(l==82) return "SECURE-VMTP"
   if(l==83) return "VINES"
   if(l==84) return "TTP"
   if(l==85) return "NSFNET-IGP"
   if(l==86) return "DGP"
   if(l==87) return "TCF"
   if(l==88) return "EIGRP"
   if(l==89) return "OSPFIGP"
   if(l==90) return "Sprite-RPC"
   if(l==91) return "LARP"
   if(l==92) return "MTP"
   if(l==93) return "AX.25"
   if(l==94) return "IPIP"
   if(l==95) return "MICP"
   if(l==96) return "SCC-SP"
   if(l==97) return "ETHERIP"
   if(l==98) return "ENCAP"
   if(l==100) return "GMTP"
   if(l==101) return "IFMP"
   if(l==102) return "PNNI"
   if(l==103) return "PIM"
   if(l==104) return "ARIS"
   if(l==105) return "SCPS"
   if(l==106) return "QNX"
   if(l==107) return "A/N"
   if(l==108) return "IPComp"
   if(l==109) return "SNP"
   if(l==110) return "Compaq-Peer"
   if(l==111) return "IPX-in-IP"
   if(l==112) return "VRRP"
   if(l==113) return "PGM"
   if(l==115) return "L2TP"
   if(l==116) return "DDX"
   if(l==117) return "IATP"
   if(l==118) return "STP"
   if(l==119) return "SRP"
   if(l==120) return "UTI"
   if(l==121) return "SMP"
   if(l==122) return "SM"
   if(l==123) return "PTP"
   if(l==124) return "ISIS"
   if(l==125) return "FIRE"
   if(l==126) return "CRTP"
   if(l==127) return "CRUDP"
   if(l==128) return "SSCOPMCE"
   if(l==129) return "IPLT"
   if(l==130) return "SPS"
   if(l==131) return "PIPE"
   if(l==132) return "SCTP"
   if(l==133) return "FC"
   return ""
}

function _sock_family_str(f) {
   if(f==0) return "PF_UNSPEC"
   if(f==1) return "PF_UNIX"
   if(f==1) return "PF_LOCAL"
   if(f==2) return "PF_INET"
   if(f==3) return "PF_AX25"
   if(f==4) return "PF_IPX"
   if(f==5) return "PF_APPLETALK"
   if(f==6) return "PF_NETROM"
   if(f==7) return "PF_BRIDGE"
   if(f==8) return "PF_ATMPVC"
   if(f==9) return "PF_X25"
   if(f==10) return "PF_INET6"
   if(f==11) return "PF_ROSE"
   if(f==12) return "PF_DECnet"
   if(f==13) return "PF_NETBEUI"
   if(f==14) return "PF_SECURITY"
   if(f==15) return "PF_KEY"
   if(f==16) return "PF_NETLINK"
   if(f==17) return "PF_PACKET"
   if(f==18) return "PF_ASH"
   if(f==19) return "PF_ECONET"
   if(f==20) return "PF_ATMSVC"
   if(f==22) return "PF_SNA"
   if(f==23) return "PF_IRDA"
   if(f==24) return "PF_PPPOX"
   if(f==25) return "PF_WANPIPE"
   if(f==26) return "PF_LLC"
   if(f==31) return "PF_BLUETOOTH"
   if(f==32) return "PF_MAX"
   return ""
}

function _sock_type_str(t) {
   if(t==1) return "SOCK_STREAM"
   if(t==2) return "SOCK_DGRAM"
   if(t==5) return "SOCK_SEQPACKET"
   if(t==3) return "SOCK_RAW"
   if(t==4) return "SOCK_RDM"
   if(t==10) return "SOCK_PACKET"
   return ""
}

function _opoll_op_str(o) {
   if(o==1) return "EPOLL_CTL_ADD"
   if(o==3) return "EPOLL_CTL_MOD"
   if(o==2) return "EPOLL_CTL_DEL"
   return ""
}

function _epoll_events_str(e) {
   if(e==1) return "EPOLLIN"
   if(e==4) return "EPOLLOUT"
   if(e==2) return "EPOLLPRI"
   if(e==8) return "EPOLLERR"
   if(e==16) return "EPOLLHUP"
   if(e==-2147483648) return "EPOLLET"
   if(e==1073741824) return "EPOLLONESHOT"
   return ""
}

function _rlimit_resource_str(r) {
   if(r==-1) return "RLIM_INFINITY"
   if(r==9) return "RLIMIT_AS"
   if(r==4) return "RLIMIT_CORE"
   if(r==0) return "RLIMIT_CPU"
   if(r==2) return "RLIMIT_DATA"
   if(r==1) return "RLIMIT_FSIZE"
   if(r==10) return "RLIMIT_LOCKS"
   if(r==8) return "RLIMIT_MEMLOCK"
   if(r==7) return "RLIMIT_NOFILE"
   if(r==6) return "RLIMIT_NPROC"
   if(r==5) return "RLIMIT_RSS"
   if(r==3) return "RLIMIT_STACK"
   return ""
}

function _rusage_who_str(w) {
   if(w==0) return "RUSAGE_SELF"
   if(w==-1) return "RUSAGE_CHILDREN"
   return ""
}
