// memory/vm related tapset
// Copyright (C) 2005, 2006 IBM Corp.
// Copyright (C) 2006 Intel Corporation.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

/**
 * probe vm.pagefault - Records that a page fault occurred.
 * @address: The address of the faulting memory access; i.e. the address that caused the page fault.
 * @write_access: Indicates whether this was a write or read access; <command>1</command> indicates a write,
 * while <command>0</command> indicates a read.
 *
 * Context: The process which triggered the fault
 */
probe vm.pagefault = kernel.function("__handle_mm_fault@mm/memory.c") ?,
                     kernel.function("handle_mm_fault@mm/memory.c") ?
{
	write_access = $write_access
	address =  $address
}

/**
 * probe vm.pagefault.return - Indicates what type of fault occurred.
 * @fault_type: Returns either 
 * <command>0</command> (VM_FAULT_OOM) for out of memory faults, 
 * <command>2</command> (VM_FAULT_MINOR) for minor faults, <command>3</command> (VM_FAULT_MAJOR) for 
 * major faults, or <command>1</command> (VM_FAULT_SIGBUS) if the fault was neither OOM, minor fault, 
 * nor major fault.
 */
probe vm.pagefault.return = kernel.function("__handle_mm_fault@mm/memory.c").return ?,
                            kernel.function("handle_mm_fault@mm/memory.c").return ?
{
	fault_type = $return
}

/**
 * sfunction addr_to_node - Returns which node a given address belongs to within a NUMA system.
 * @addr: The address of the faulting memory access.
 *
 */
function addr_to_node:long(addr:long) %{ /* pure */ 
	int nid;
	int pfn = __pa(THIS->addr) >> PAGE_SHIFT;
	for_each_online_node(nid)
		if ( NODE_DATA(nid)->node_start_pfn <= pfn &&
			pfn < (NODE_DATA(nid)->node_start_pfn +
			NODE_DATA(nid)->node_spanned_pages) )
		{
			THIS->__retvalue = nid;
			break;
		}
%}

/* Return whether a page to be copied is a zero page. */
function _IS_ZERO_PAGE:long(from:long, vaddr:long) %{ /* pure */
    THIS->__retvalue = (THIS->from == (long) ZERO_PAGE(THIS->vaddr));
%}


/**
 * probe vm.write_shared - Attempts at writing to a shared page.
 * @address: The address of the shared write.
 *
 * Context:
 *  The context is the process attempting the write.
 *
 *  Fires when a process attempts to write to a shared page.
 *  If a copy is necessary, this will be followed by a
 *  <command>vm.write_shared_copy</command>.
 */
probe vm.write_shared = kernel.function("do_wp_page") {
    address = $address
}

/**
 * probe vm.write_shared_copy- Page copy for shared page write.
 * @address: The address of the shared write.
 * @zero: Boolean indicating whether it is a zero page
 *         (can do a clear instead of a copy).
 *
 * Context:
 *  The process attempting the write.
 *
 *  Fires when a write to a shared page requires a page copy.  This is
 *  always preceded by a <command>vm.shared_write</command>.
 */
probe vm.write_shared_copy = kernel.function("copy_cow_page")? {
    address = $address
    zero = _IS_ZERO_PAGE($from, address);
}


/**
 * probe vm.mmap - Fires when an <command>mmap</command> is requested.
 * @address: The requested address
 * @length: The length of the memory segment 
 *
 * Context:
 *  The process calling <command>mmap</command>.
 */
probe vm.mmap = kernel.function("do_mmap"), kernel.function("do_mmap2")? {
    address = $addr
    length = $len
}


/**
 * probe vm.munmap - Fires when an <command>munmap</command> is requested.
 * @address: The requested address
 * @length: The length of the memory segment 
 *
 * Context:
 *  The process calling <command>munmap</command>.
 */
probe vm.munmap = kernel.function("do_munmap") {
    address = $start
    length = $len
}

/**
 * probe vm.brk - Fires when a <command>brk</command> is requested (i.e. the heap will be resized).
 * @address: The requested address
 * @length: The length of the memory segment 
 *
 * Context:
 *  The process calling <command>brk</command>.
 */
probe vm.brk = kernel.function("do_brk") {
    address = $addr
    length = $len
}

/**
 * probe vm.oom_kill - Fires when a thread is selected for termination by the OOM killer.
 * @task: The task being killed
 *
 * Context:
 *  The process that tried to consume excessive memory, and thus
 *  triggered the OOM. <remark>(is this correct?)</remark>
 */
probe vm.oom_kill = kernel.function("__oom_kill_task") {
    task = $p
}
