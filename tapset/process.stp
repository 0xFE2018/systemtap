// process tapset
// Copyright (C) 2006 Intel Corporation.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.


function _IS_ERR:long(ptr:long) %{
    THIS->__retvalue = IS_ERR((const void *)(long)THIS->ptr);
%}


/* probe process.create
 *
 *  Fires whenever a new process is successfully created, either as a result of
 *  one of the fork syscall variants, or a new kernel thread.
 *
 * Context:
 *  Parent of the created process.
 *
 * Arguments:
 *  task - a handle to the newly created process.
 */
probe process.create = kernel.function("copy_process").return {
    task = retval()
    new_pid = task_pid(task)
    if (_IS_ERR(task)) next
}


/* probe process.start
 *
 *  Fires immediately before a new process begins execution.
 *
 * Context:
 *  Newly created process.
 */
probe process.start = kernel.function("schedule_tail") { }


/* probe process.exec
 *
 *  Fires whenever a process attempts to exec to a new program.
 *
 * Context:
 *  The caller of exec.
 *
 * Arguments:
 *  filename - the path to the new executable
 */
probe process.exec = 
/*
    kernel.function("do_execve")
%( arch != "i586" %? %( arch != "i686" %? 
  , kernel.function("compat_do_execve")
%) %)
*/
    kernel.function("*do_execve")
{
    filename = kernel_string($filename)
}


/* probe process.exec_complete
 *
 *  Fires at the completion of an exec call.
 *
 * Context:
 *  On success, the context of the new executable.
 *  On failure, remains in the context of the caller.
 *
 * Arguments:
 *  errno - the error number resulting from the exec
 *  success - a boolean indicating whether the exec was successful
 */
probe process.exec_complete =
/*
    kernel.function("do_execve").return
%( arch != "i586" %? %( arch != "i686" %? 
  , kernel.function("compat_do_execve").return
%) %)
*/
    kernel.function("*do_execve").return
{
    errno = retval()
    success = (errno >= 0)
}


/* probe process.exit
 *
 *  Fires when a process terminates.  This will always be followed by a
 *  process.release, though the latter may be delayed if the process waits in a
 *  zombie state.
 *
 * Context:
 *  The process which is terminating.
 *
 * Arguments:
 *  code - the exit code of the process
 */
probe process.exit = kernel.function("do_exit") {
    code = $code
}


/* probe process.release
 *
 *  Fires when a process is released from the kernel.  This always follows a
 *  process.exit, though it may be delayed somewhat if the process waits in a
 *  zombie state.
 *
 * Context:
 *  The context of the parent, if it wanted notification of this process'
 *  termination, else the context of the process itself.
 *
 * Arguments:
 *  task - a task handle to the process being released
 */
probe process.release = kernel.function("release_task") {
    task = $p
}


/* probe process.signal_send
 *
 *  Fires when a process sends a signal to another process.  This does not
 *  include ignored signals.
 *
 * Context:
 *  The signal's sender.
 *
 * Arguments:
 *  signal - the number of the signal
 *  signal_name - a string representation of the signal
 *  task - a task handle to the signal recipient
 *  shared - indicates whether this signal is shared by the thread group
 */
probe process.signal_send = _process.signal_send.* {
    signal = $sig
    signal_name = _signal_name($sig)
}

probe _process.signal_send.part1 =
        kernel.function("__group_send_sig_info"),
        kernel.function("send_group_sigqueue")
{
    task = $p
    shared = 1
}

probe _process.signal_send.part2 =
        kernel.function("send_sigqueue")
{
    task = $p
    shared = 0
}

probe _process.signal_send.part3 =
        kernel.function("specific_send_sig_info")
{
    task = $t
    shared = 0
}


/* probe process.signal_handle
 *
 *  Fires when a process handles a signal.
 *
 * Context:
 *  The signal recipient.
 *
 * Arguments:
 *  signal - the number of the signal
 *  signal_name - a string representation of the signal
 */
/* FIXME - handle_signal is sometimes inlined, depending on the whims of the
 * compiler.  On FC5 it is inlined, but on RHEL4 it is not.  Until we have a
 * nice way for tapsets to specify "possibly inlined", we can't include this
 * probe point.
probe process.signal_handle = kernel.function("handle_signal") {
    signal = $sig
    signal_name = _signal_name($sig)
}
*/
