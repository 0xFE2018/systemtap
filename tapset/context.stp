// context tapset
// Copyright (C) 2005, 2006 Red Hat Inc.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

function print_regs () %{
	if (CONTEXT->regs) {
		_stp_print_regs (CONTEXT->regs);
	}
%}

function print_backtrace () %{
	if (CONTEXT->regs) {
		_stp_stack_print(CONTEXT->regs);
	}
%}

function backtrace:string () %{ /* pure */
	if (CONTEXT->regs) {
                /* XXX: this won't be necessary when runtime and translator */
		/* agree on what a string is. */
		String str = _stp_string_init (0);
		_stp_stack_sprint (str, CONTEXT->regs, 0);	
		strlcpy (THIS->__retvalue, _stp_string_ptr(str), MAXSTRINGLEN);
	} else 
		strlcpy (THIS->__retvalue, "", MAXSTRINGLEN);
%}

function execname:string () %{ /* pure */
	strlcpy (THIS->__retvalue, current->comm, MAXSTRINGLEN);
%}

function pid:long () %{ /* pure */
	THIS->__retvalue = current->tgid;
%}

function tid:long () %{ /* pure */
	THIS->__retvalue = current->pid;
%}

function ppid:long () %{ /* pure */
	THIS->__retvalue = current->parent->tgid;
%}

function pexecname:string () %{ /* pure */
	strlcpy (THIS->__retvalue, current->parent->comm, MAXSTRINGLEN);
%}

function gid:long () %{ /* pure */
	THIS->__retvalue = current->gid;		
%}

function egid:long () %{ /* pure */
	THIS->__retvalue = current->egid;		
%}

function uid:long () %{ /* pure */
	THIS->__retvalue = current->uid;		
%}

function euid:long () %{ /* pure */
	THIS->__retvalue = current->euid;		
%}

function cpuid:long () %{ /* pure */
	THIS->__retvalue = current->thread_info->cpu;
%}

function cpu:long () %{ /* pure */
	THIS->__retvalue = current->thread_info->cpu; /* smp_processor_id()? */
%}

function print_stack(stk:string) %{
	char *ptr = THIS->stk;
	char *tok = strsep(&ptr, " ");
	while (tok && *tok) {
		_stp_print_cstr(" ");
		_stp_symbol_print (simple_strtol(tok, NULL, 16));
		_stp_print_cstr("\n");
		tok = strsep(&ptr, " ");
	}
%}

function pp:string () %{ /* pure */
	strlcpy (THIS->__retvalue, CONTEXT->probe_point, MAXSTRINGLEN);
%}

function probefunc:string () %{ /* pure */
	char *dst, *ptr, *start;
	String str;
	int len = MAXSTRINGLEN;

	start = strstr(CONTEXT->probe_point, "function(\"");
	ptr = start + 10; 
	if (!start) {
		start = strstr(CONTEXT->probe_point, "inline(\"");
		ptr = start + 8;
	}
	if (start) {
		dst = THIS->__retvalue;
		while (*ptr != '@' && --len > 0 && *ptr)
			*dst++ = *ptr++;
		*dst = 0;
	} else if (CONTEXT->regs) {
		str  = _stp_string_init (0);
		_stp_symbol_sprint(str, REG_IP(CONTEXT->regs));
		start = strstr(_stp_string_ptr(str), " : ");
		if (start) {
			dst = THIS->__retvalue;
			ptr = start+3;
			while (*ptr != '+' && --len > 0 && *ptr)
				*dst++ = *ptr++;
			*dst = 0;
		}
		else {
			strlcpy(THIS->__retvalue, _stp_string_ptr(str),MAXSTRINGLEN);
		}
	} else {
        THIS->__retvalue[0] = '\0';
    }
%}

function is_return:long () %{ /* pure */
	char *ptr = strrchr(CONTEXT->probe_point, '.');
	if (ptr) {
		if (strcmp(ptr+1,"return") == 0)
			THIS->__retvalue = 1;
	}
%}

function target:long () %{ /* pure */
        THIS->__retvalue = _stp_target;
%}

function returnval () { return retval () }  # deprecated
