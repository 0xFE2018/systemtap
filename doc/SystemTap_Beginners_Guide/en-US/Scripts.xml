<?xml version='1.0'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>

<section id="scripts">
	<title>SystemTap Scripts</title>
	
	<para>
		For the most part, SystemTap scripts are the foundation of each SystemTap session. SystemTap scripts instruct SystemTap on what type of information to collect, and what to do once that information is collected.
	</para>
	
	<para>
		As stated in <xref linkend="understanding-how-systemtap-works"/>, SystemTap scripts are made up of two components: <emphasis>events</emphasis> and <emphasis>handlers</emphasis>. Once a SystemTap session is underway, SystemTap monitors the operating system for the specified events and executes the handlers as they occur. 
	</para>
	
	
<note>
	<title>Note</title>
	<para>An event and its corresponding handler is collectively called a <emphasis>probe</emphasis>. A SystemTap script can have multiple probes.</para>
	
	<para>A probe's handler is also commonly referred to as a <emphasis>probe body</emphasis>.</para>
</note>	
	
<para>
	In terms of application development, using events and handlers is similar to inserting diagnostic print statements in a program's sequence of commands. These diagnostic print statements allow you to view a history of commands executed once the program is run. 
	</para>	
<!--	<para>
		In terms of application development, using events and handlers is similar to inserting <command>print</command> statements in a program's sequence of commands. These <command>print</command> statements allow you to view a history of commands executed once the program is run. 
	</para>	-->
	
	<para>
		SystemTap scripts go one step further by allowing you more flexibility with regard to handlers. Events serve as the triggers for handlers to run; handlers can be specified to trap specified data and print it in a certain manner. 
	</para>
	
<formalpara id="scriptformats">
	<title>Format</title>
	<para>
		SystemTap scripts use the file extension <filename>.stp</filename>, and are written in the following format:
	</para>
</formalpara>	
<programlisting>
probe	<replaceable>event</replaceable>,

{
	<replaceable>handler</replaceable>
}
</programlisting>		
<!--
	<para>The <replaceable>exit()</replaceable> condition is optional; this condition safely terminates the session once the script successfully collects the required information the first time.</para>	
	-->
<important>
	<title>Important</title>
	<para>
		<xref linkend="scripts"/> is designed to introduce readers to the basics of SystemTap scripts. To understand SystemTap scripts better, it is advisable that you refer to <xref linkend="useful-systemtap-scripts"/>; each section therein provides a detailed explanation of the script, its events, handlers, and expected output.
	</para>
</important>	
	<section id="systemtapscript-events">
		<title>Events</title>
	
<para>SystemTap events can be broadly classified into two types: <firstterm>synchronous</firstterm> and <firstterm>asynchronous</firstterm>.</para>

<formalpara><title>Synchronous Events</title>
<para>A <firstterm>synchronous</firstterm> event occurs when any process executes an instruction that references a particular location in kernel code. This gives other events a reference point from which more contextual data may be available. </para>
</formalpara>

<!--<para>A <firstterm>synchronous</firstterm> event occurs when any processor executes an instruction matched by the specification. This gives other events a reference point (or instruction address) from which more contextual data may be available.</para>-->

<!--<para>Synchronous events reference particular locations in kernel code. As a result, when synchronous events are used SystemTap can determine contextual  information regarding the location (such as function parameters).</para>-->

<para>Examples of synchronous events include:</para>

<variablelist>
<varlistentry>
	<term>kernel.function("<replaceable>function</replaceable>")</term>
	<listitem>
		<para>The entry to the kernel function <replaceable>function</replaceable>. For example, <command>kernel.function("sys_open")</command> refers to the "event" that occurs when the kernel function <command>sys_open</command> is called by any thread in the system. To specify the <emphasis>return</emphasis> of the kernel function <command>sys_open</command>, append the <command>return</command> string to the event statement; i.e. <command>kernel.function("sys_open").return</command>.</para>
		
		<para>When defining functions, you can use asterisk (<literal>*</literal>) for wildcards. You can also trace the entry or exit of a function in a kernel source file. Consider the following example:</para>
<example id="wildcards"><title>wildcards.stp</title>
<programlisting>
probe kernel.function("*@net/socket.c") { }
probe kernel.function("*@net/socket.c").return { }
</programlisting>	
</example>	

<para>In the previous example, the first probe's event specifies the entry of ALL functions in the kernel source file <filename>net/socket.c</filename>. The second probe specifies the exit of all those functions. Note that in this example, no handler was specified; as such, no information will be displayed.</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>syscall.<replaceable>system_call</replaceable></term>
	<listitem>
		<para>The entry to the system call <replaceable>system_call</replaceable>. Similar to <command>kernel.function</command>, appending a <command>return</command> to the statement specifies the exit of the system call. For example, to specify the entry of the system call <command>close</command>, use <command>syscall.close.return</command>.</para>
		
		<para>To identify what system calls are made by a specific program/command, use <command>strace <replaceable>command</replaceable></command>.</para>
	</listitem>	
</varlistentry>
	
<varlistentry>
	<term>module("<replaceable>module</replaceable>").function("<replaceable>function</replaceable>")</term>
	<listitem>
		<para>Allows you to probe functions within modules. For example:</para>
		
<example id="eventsmodules"><title>moduleprobe.stp</title>
<programlisting>
probe module("ext3").function("*") { }
probe module("ext3").function("*").return { }
</programlisting>	
		</example>
		
		<para>
			The first probe in <xref linkend="eventsmodules"/> points to the entry of <emphasis>all</emphasis> functions for the <filename>ext3</filename> module. The second probe points to the exits of all entries for that same module; the use of the <command>.return</command> suffix is similar to <command>kernel.function()</command>. Note that the probes in <xref linkend="eventsmodules"/> also do not contain probe bodies, and as such will not print any useful data (as in <xref linkend="wildcards"/>). 
		</para>	
		
		<para>
			A system's loaded modules are typically located in <filename>/lib/modules/<replaceable>kernel version</replaceable></filename>, where <replaceable>kernel version</replaceable> refers to the currently loaded kernel. Modules use the filename extension <filename>.ko</filename>. 
		</para>	
		
	</listitem>	
</varlistentry>	
</variablelist>	

	
<formalpara>
	<title>Asynchronous Events</title>
	<para><firstterm>Asynchronous</firstterm> events, on the other hand, occur as instructed in the probe itself, rather than waiting for a particular instruction in kernel code to be executed by a process. This family of probe points consists mainly of counters, timers, and similar constructs.</para>
<!--	<para><firstterm>Asynchronous</firstterm> events, on the other hand, do not point to any reference point. This family of probe points consists mainly of counters, timers, and similar constructs.</para>-->
</formalpara>

	<para>Examples of asynchronous events include:</para>

<variablelist>
	
<varlistentry>
	<term>begin</term>
	<listitem>
		<para>The startup of a SystemTap session; i.e. as soon as the SystemTap script is run.</para>
	</listitem>	
</varlistentry>	

<varlistentry>
	<term>end</term>
	<listitem>
		<para>The end of a SystemTap session.</para>
	</listitem>	
</varlistentry>



<varlistentry>
	<term>timer events</term>
	<listitem>
		<para>An event that specifies a handler to be executed every  specified period of time. For example:</para>
		
<example id="timer"><title>timer-ms.stp</title>		
<programlisting>
probe timer.ms(4000)
{
	printf("hello world\n")
}
</programlisting>
</example>

<para>
	<xref linkend="timer"/> is an example of a probe that prints <command>hello world</command> every 4000 milliseconds. Note that you can also use the following timer events:
</para>
	
<itemizedlist>
<listitem><para><command>timer.s(<replaceable>seconds</replaceable>)</command></para></listitem>

<listitem><para><command>timer.us(<replaceable>microseconds</replaceable>)</command></para></listitem>

<listitem><para><command>timer.ns(<replaceable>nanoseconds</replaceable>)</command></para></listitem>

<listitem><para><command>timer.hz(<replaceable>hertz</replaceable>)</command></para></listitem>

<listitem><para><command>timer.jiffies(<replaceable>jiffies</replaceable>)</command></para></listitem>

</itemizedlist>
<para>
	When used in conjunction with another probe that collects information that updates periodically, timer events allows you to see how that information changes over time. 
</para>	
<!--
<para>
	When used in conjunction with another probe that collects a large quantity of data, timer events allow you to limit the information your script is collecting (and printing out). It is also useful for collecting periodically updating information.
</para>	-->
		
	</listitem>	
</varlistentry>



<!--<remark>add timer.ms() to events list!</remark>-->
<!--	
<varlistentry>
	<term></term>
	<listitem>
		<para></para>
	</listitem>	
</varlistentry>
-->
	
</variablelist>

<important>
	<title>Important</title>
	<para>
	SystemTap supports the use of a large collection of probe events. For more information about supported events, refer to <command>man stapprobes</command>. The <citetitle>SEE ALSO</citetitle> section of <command>man stapprobes</command> also contains links to other <command>man</command> pages that discuss supported events for specific subsystems and components.
	</para>	
</important>

<para>
	SystemTap supports multiple events per probe; as shown in <xref linkend="scriptformats"/>, multiple events are delimited by a comma (<command>,</command>). If multiple events are specified in a single probe, SystemTap will execute the handler when any of the specified events occur. 
</para>	

<remark>is reference appropriate? too advanced for readers (it seems so to me)? please advise.</remark> 

	</section>
	
	<section id="systemtapscript-handlers">
		<title>Handlers/Probe Body</title>

<para>
Consider the following sample script:
</para>

<example id="helloworld"><title>helloworld.stp</title>
<programlisting>
probe begin
{
  printf ("hello world\n")
  exit ()
}
</programlisting>	
</example>

<para>
	In <xref linkend="helloworld"/>, the event <command>begin</command> (i.e. the start of the session) triggers the handler enclosed in <command>{ }</command>, which simply prints <command>hello world</command>, then exits.
</para>	

<formalpara id="printf">
	<title>printf ( ) Statements</title>
<para>
	The <command>printf ()</command> statement is one of the simplest functions for printing data. <command>printf ()</command> can also be used to display data using a wide variety of SystemTap functions in the following format:
</para>

</formalpara>


<programlisting>
printf ("<replaceable>format string</replaceable>\n", <replaceable>argument</replaceable>)
</programlisting>

<para>
	The <replaceable>format string</replaceable> region specifies how <replaceable>argument</replaceable> should be displayed. The format string of <xref linkend="helloworld"/> simply instructs SystemTap to print <command>hello world</command>, and contains no arguments. 
</para>

<para>
	You can use the variables <command>%s</command> (for strings) and <command>%d</command> (for numbers) in format strings, depending on your list of arguments. Format strings can have multiple variables, each matching a corresponding argument; multiple arguments are delimited by a comma (<command>,</command>) and space.
</para>

<note>
	<title>Note</title>
	<para>Semantically, the SystemTap <command>printf</command> function is very similar to its C language counterpart. The aforementioned syntax and format for SystemTap's <command>printf</command> function is identical to that of the C-style <command>printf</command>.</para>
</note>	

<para>
	To illustrate this, consider the following probe example:
</para>

<example id="syscall-open">
	<title>variables-in-printf-statements.stp</title>
<programlisting>
# This probe will need to be manually terminated with Ctrl-C
probe syscall.open
{
  printf ("%s(%d) open\n", execname(), pid())
}
	
</programlisting>	
</example>

<para>
<xref linkend="syscall-open"/> instructs SystemTap to probe all entries to the system call <command>open</command>; for each event, it prints the current <command>execname()</command> (which is a string) and <command>pid()</command> (which is a number), followed by the word <command>open</command>. A snippet of this probe's output would look like:
</para>

<remark>editorial review: does a clarification that "variable1" is to "argument1", "variable2" is to "argument2", or is this clear enough?</remark>

<screen>
vmware-guestd(2206) open
hald(2360) open
hald(2360) open
hald(2360) open
df(3433) open
df(3433) open
df(3433) open
hald(2360) open
</screen>

<formalpara>
	<title>SystemTap Functions</title>	
	<para>SystemTap supports a wide variety of functions that can be used as <command>printf ()</command> arguments. <xref linkend="syscall-open"/> uses the SystemTap functions <command>execname()</command> (current process name) and <command>pid()</command> (current process ID).</para>
</formalpara>		

<remark>is "handler function" an appropriate term? wcohen: use "SystemTap functions" to match up language in man pages</remark>

	<para>The following is a list of commonly-used SystemTap functions:</para>	
<variablelist>

<varlistentry>
	<term>tid()</term>
	<listitem>
		<para>The ID of the current thread.</para>
	</listitem>	
</varlistentry>	

<varlistentry>
	<term>uid()</term>
	<listitem>
		<para>The ID of the current user.</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>cpu()</term>
	<listitem>
		<para>The current CPU number.</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>gettimeofday_s()</term>
	<listitem>
		<para>The number of seconds since UNIX epoch (January 1, 1970).</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>get_cycles()</term>
	<listitem>
		<para>A snapshot of the hardware cycle counter.</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>pp()</term>
	<listitem>
		<para>A string describing the probe point currently being handled.</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>probefunc()</term>
	<listitem>
		<para>If known, the name of the function in which the probe was placed.</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>thread_indent()</term>
	<listitem>
		<para>This particular function is quite useful, providing you with a way to better organize your print results. When used with an indentation parameter (for example, <command>-1</command>), it allows the probe to internally store an "indentation counter" for each thread (identified by ID, as in <command>tid</command>). It then returns a string with some generic trace data along with an appropriate number of indentation spaces.</para>
		
		<para>The generic data included in the returned string includes a timestamp (number of microseconds since the most recent initial indentation), a process name, and the thread ID. This allows you to identify what functions were called, who called them, and the duration of each function call.
		</para>	
		
		<para>
			Consider the following example on the use of <command>thread_indent()</command>:
		</para>
		
<example id="thread_indent"><title>thread_indent.stp</title>
<programlisting>
probe kernel.function("*@net/socket.c") 
{
	printf ("%s -> %s\n", thread_indent(1), probefunc())
}
probe kernel.function("*@net/socket.c").return 
{
	printf ("%s &lt;- %s\n", thread_indent(-1), probefunc())
}
</programlisting>
</example>
	<para><xref linkend="thread_indent"/> prints out the <command>thread_indent()</command> and probe functions at each event in the following format:</para>
	
<screen>
     0 ftp(7223): -&gt; sys_socketcall
  1159 ftp(7223): -&gt; sys_socket
  2173 ftp(7223):   -&gt; __sock_create
  2286 ftp(7223):    -&gt; sock_alloc_inode
  2737 ftp(7223):    &lt;- sock_alloc_inode
  3349 ftp(7223):    -&gt; sock_alloc
  3389 ftp(7223):    &lt;- sock_alloc
  3417 ftp(7223):   &lt;- __sock_create
  4117 ftp(7223):   -&gt; sock_create
  4160 ftp(7223):   &lt;- sock_create
  4301 ftp(7223):   -&gt; sock_map_fd
  4644 ftp(7223):    -&gt; sock_map_file
  4699 ftp(7223):    &lt;- sock_map_file
  4715 ftp(7223):   &lt;- sock_map_fd
  4732 ftp(7223): &lt;- sys_socket
  4775 ftp(7223): &lt;- sys_socketcall
</screen>

<remark>remember to add a reference later to "tapsets" from here, to clarify that thread_indent is defined in tapsets as a special function of sorts</remark>
	
	</listitem>	
</varlistentry>

<varlistentry>
	<term>name</term>
	<listitem>
		<para>Identifies the name of a specific system call.</para>
	</listitem>	
</varlistentry>

<varlistentry>
	<term>target()</term>
	<listitem>
		<para>Used in conjunction with <command>stap <replaceable>script</replaceable> -x <replaceable>process ID</replaceable></command> or <command>stap <replaceable>script</replaceable> -c <replaceable>command</replaceable></command>. If you want to specify a script to take an argument of a process ID or command, use <command>target()</command> as the variable in the script to refer to it. For example:</para>
			
<example id="targetexample">
	<title>targetexample.stp</title>
<programlisting>
probe syscall.* {
	if (pid() == target()) {
		printf("%s/n", name)
	}}	
</programlisting>
</example>

	<para>When <xref linkend="targetexample"/> is run with the argument <command>-x <replaceable>process ID</replaceable></command>, it watches all system calls (as specified by the event <command>syscall.*</command>) and prints out the name of all system calls made by the specified process.</para>
	
	<para>This has the same effect as specifying <command>if (pid() == <replaceable>process ID</replaceable></command> each time you wish to target a specific process. However, using <command>target()</command> makes it easier for you to re-use the script, giving you the ability to simply pass a process ID as an argument each time you wish to run the script (e.g. <command>stap targetexample.stp -x <replaceable>process ID</replaceable></command>).</para>
<!--		
<note>
	<title>Note</title>
	<para>In <xref linkend="targetexample"/>, <command>name</command> instructs SystemTap to capture the name of the process</para>
</note>	-->
		
	</listitem>	
</varlistentry>

<!--	
<varlistentry>
	<term></term>
	<listitem>
		<para></para>
	</listitem>	
</varlistentry>
-->	
</variablelist>		

<para>For more information about supported SystemTap functions, refer to <command>man stapfuncs</command>.</para>

<remark>will need a complete listing of supported handler functions? also, SystemTap function descriptions seem ambiguous, please advise.</remark>

<!--	
<para>
	<replaceable>variable</replaceable> can be either <command>%s</command> for strings, or <command>%d</command> for numbers, depending on the <replaceable>handler function</replaceable> used. Each <command>printf ()</command> statement can contain multiple <replaceable>variable</replaceable>s, with each one corresponding to a matching <replaceable>handler function</replaceable>. Multiple <replaceable>handler function</replaceable>s are delimited by comma (<command>,</command>). 
</para>	

	<command>printf ()</command> is a SystemTap-supported C statement, and can also trap data using a wide variety
	
	SystemTap supports a wide variety of handler functions that can trap data when triggered by events. One way to display these functions is to use the <command>print()</command>   
</para>	
		
		
<para>
	<xref linkend="wildcards"/> illustrates an example of a SystemTap script that contains no handlers. SystemTap will still be able to run the script, but no information will be displayed. 	
</para>
-->


	</section>
	<section id="handlerconditionals">
		<title>Basic Handler Constructs</title>
			
<para>SystemTap supports the use of several basic constructs in handlers. The syntax for most of these handler constructs are mostly based on C and <command>awk</command> syntax. This section describes several of the most useful SystemTap handler constructs.</para>

<formalpara id="variablesconstructs">
	<title>Variables</title>
		
	<para>Variables can be used freely throughout a handler; simply choose a name, assign it to a function, and use it in an expression. SystemTap automatically identifies whether a variable should be identified as a string or integer, based on the function it is assigned to. For instance, if you use set the variable <command>foo</command> to <command>gettimeofday_s()</command> (as in <command>foo = gettimeofday_s()</command>), then <command>foo</command> can be used as an integer argument (<command>%d</command>) in <command>printf()</command>.</para>
</formalpara>

<para>Note, however, that by default variables are only local to the probe they are used in. This means that variables are initialized, used and disposed at each probe handler invocation. To share a variable between probes, declare the variable name first using <command>global</command> outside of any probe. Consider the following example:</para>

<example id="timerjiffies">
	<title>timer-jiffies.stp</title>
<programlisting>
global count_jiffies, count_ms
probe timer.jiffies(100) { count_jiffies ++ }
probe timer.ms(100) { count_ms ++ }
probe timer.ms(12345)
{
  hz=(1000*count_jiffies) / count_ms
  printf ("jiffies:ms ratio %d:%d => CONFIG_HZ=%d\n",
    count_jiffies, count_ms, hz)
  exit ()
}
</programlisting>
</example>
	
<para><xref linkend="timerjiffies"/> attempts to compute the <command>CONFIG_HZ</command> setting of the kernel using timers that count jiffies and milliseconds, then computing accordingly. The <command>global</command> statement allows the script to use the variables <command>count_jiffies</command> and <command>count_ms</command> (set in their own respective probes) to be shared with <command>probe timer.ms(12345)</command>.</para>

<note>
	<title>Note</title>
	<para>In some cases, such as in <xref linkend="timerjiffies"/>, a variable may be declared without any specific value as yet. You need to declare such values as integers using the notation <command>++</command>.</para>
</note>	
	
	


<formalpara>
	<title>Conditional Statements</title>
<para>
In some cases, the output of a SystemTap script may be too big. To address this, you need to further refine the script's logic in order to delimit the output into something more relevant or useful to your probe.
</para>
</formalpara>
<para>
You can do this by using <emphasis>conditionals</emphasis> in handlers. SystemTap accepts the following types of conditional statements:
</para>

<variablelist>
<varlistentry>
	<term>If/Else Statements</term>
	<listitem>
		<para>Format:</para>
<programlisting>
{ 
if (<replaceable>condition</replaceable>) 
	{<replaceable>handler</replaceable>} [else {<replaceable>handler</replaceable>}]
}
</programlisting>
	</listitem>	
</varlistentry>	
	
<varlistentry>
	<term>While Loops</term>
	<listitem>
		<para>Format:</para>
<programlisting>
{
while (<replaceable>condition</replaceable>) {<replaceable>handler</replaceable>}
}
</programlisting>	
	</listitem>	
</varlistentry>	

<varlistentry>
	<term>For Loops</term>
	<listitem>
		<para>Format:</para>
<programlisting>
{
for (<replaceable>argument1</replaceable>; <replaceable>argument2</replaceable>; <replaceable>argument3</replaceable>) {<replaceable>handler</replaceable>}
}
</programlisting>	
	</listitem>	
</varlistentry>

<!--<para>Each conditional statement must be enclosed in <command>{ }</command>.</para>-->
<!--	
<varlistentry>
	<term></term>
	<listitem>
		<para></para>
	</listitem>	
</varlistentry>
-->	
	
</variablelist>	
	
<para>These constructs are better illustrated in the different examples available in <xref linkend="useful-systemtap-scripts"/>.</para>

<remark>will get back to these ones later</remark>

<formalpara>
	<title>Command-Line Arguments</title>
	<para>You can also allow a SystemTap script to accept simple command-line arguments and declare them in the script without using <command>target()</command>. One way to do this is to use the variable notation <command>$</command> or <command>@</command>.</para>
</formalpara>


<example id="commandlineargs"><title>commandlineargs.stp</title>
<programlisting>
probe kernel.function(@1) { }
probe kernel.function(@1).return { }
</programlisting>	
</example>	

<para><xref linkend="commandlineargs"/> is similar to <xref linkend="wildcards"/> (earlier in the chapter), except that it allows you to pass the kernel function to be probed as a command-line argument (as in <command>stap commandlineargs.stp <replaceable>kernel function</replaceable></command>). You can also specify the script to accept multiple command-line arguments, noting them as <command>@1</command>, <command>@2</command>, and so on, in the order they are entered by the user.</para>

	</section>
	<!--	<section id="SystemTap_Beginners_Guide-Test-Section_2_Test">
		<title>Section 2 Test</title>
		<para>
			Test of a section
		</para>
	</section>-->

</section>

